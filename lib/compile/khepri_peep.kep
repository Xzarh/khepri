/**
 * 
 */
package (
    optimize)
with
    import 'neith/tree' tree,
    import 'neith/zipper' zipper,

    import 'khepri_ast_zipper/khepri_zipper' {khepriZipper},
    
    import 'khepri_ast/node' {modify, Node},
    import 'khepri_ast/statement' ast_statement,
    import 'khepri_ast/expression' ast_expression
in {

var concat = \args(...) ->
    [].concat.apply([], args);
    

var map = \f, x -> [].map.call(x, f);
var reduce = Function.prototype.call.bind(Array.prototype.reduce);

var flatten = \x -> (Array.isArray(x) ? reduce(x, \p, c -> p.concat(c), []) : x);

/*
 ******************************************************************************/
var peepholes = {};

var addPeephole = \type, condition, f -> {
    var entry = {
        'condition': condition,
        'map': f
    };
    peepholes[type] = (peepholes[type] ? peepholes[type].concat(entry) : [entry]);
};

/* Peepholes
 ******************************************************************************/
/**
 * Remove noop variable declarations.
 */
addPeephole('VariableDeclarator',
    \node ->
        (node.init && node.init.type === 'Identifier' && node.id.name === node.init.name),
    \_ -> null);

/**
 * Filter out empty variable declarators.
 */
addPeephole('VariableDeclaration',
    \_ -> true, 
    \node -> let
        declarations = node.declarations.filter(\x -> !!x)
    in
        modify(node, {
            'declarations': declarations
        }, {}));

/**
 * Remove empty Variable declarations.
 */
addPeephole('VariableDeclaration',
    \node -> !node.declarations.length,
    \_ -> null);

/**
 * Rewrite `return let` to a with statement.
 */
addPeephole('ReturnStatement',
    \node ->
        (node.argument && node.argument.type === 'LetExpression'),
    \node ->
        ast_statement.WithStatement.create(null,
            node.argument.bindings,
            ast_statement.BlockStatement.create(null, 
                [ast_statement.ReturnStatement.create(node.loc, node.argument.body)])));

/**
 * Rewrite top level let expressions to with statements.
 */
addPeephole('ExpressionStatement',
    \node ->
        (node.expression && node.expression.type === 'LetExpression'),
    \node ->
        ast_statement.WithStatement.create(null,
            node.expression.bindings,
            ast_statement.BlockStatement.create(null, 
                [ast_statement.ExpressionStatement.create(node.loc, node.expression.body)])));

/**
 * Curry nothing is identity.
 */
addPeephole('CurryExpression',
    \node -> !node.args.length,
    \node -> node.base);

/**
 * Rewrite left pipe of curried expression to a call.
 */
addPeephole('BinaryExpression',
    \node ->
        (node.operator === '|>' &&
            node.left.type === 'CurryExpression' || node.left.type === 'BinaryOperatorExpression' ||
            node.left.type === 'UnaryOperatorExpression' || node.left.type === 'TernaryOperatorExpression'),
    \node ->
        ast_expression.CallExpression.create(null,
            (node.left.type === 'CurryExpression' ? node.left.base : node.left),
            concat(node.left.args || [], node.right)));

/**
 * Rewrite right pipe of curried expression to a call.
 */
addPeephole('BinaryExpression',
    \node ->
        (node.operator === '<|' &&
            node.right.type === 'CurryExpression' || node.right.type === 'BinaryOperatorExpression' ||
            node.right.type === 'UnaryOperatorExpression' || node.right.type === 'TernaryOperatorExpression'),
    \node ->
        ast_expression.CallExpression.create(null,
            (node.right.type === 'CurryExpression' ? node.right.base : node.right),
            concat(node.right.args || [], node.left)));

/* Interface
 ******************************************************************************/
var opt = \z -> {
    var t = tree.modifyNode(\node -> {
        if (!node) return node;
        var transforms = (peepholes[node.type] || []).filter(\x -> x.condition(node));
        return transforms.reduce(\p c -> c.map(p), node);
    }, z);
    
    var next = zipper.nextDfs(t);
    return (next ? opt(next) : t);
};

optimize = \node -> 
    (opt(khepriZipper(node))
        |> zipper.root
        |> tree.node);

}
