/**
 * @fileOverview
 * 
 * @TODO Better data structure (Zipper?) and eliminate mutation.
 */
package (
    check)
with
    import 'khepri_ast/node' ast_node,
    import 'khepri_ast/pattern' ast_pattern,
    import 'khepri_ast/value' ast_value
in {

var map = Function.prototype.call.bind(Array.prototype.map);
var reduce = Function.prototype.call.bind(Array.prototype.reduce);
var reduceRight = Function.prototype.call.bind(Array.prototype.reduceRight);

var copy = \obj ->
    Object.keys(obj).reduce(\p, c -> {
        p[c] = obj[c];
        return p;
    }, new obj.constructor());

var defineProperty = \obj, prop, descriptor ->
    Object.defineProperty(copy(obj), prop, descriptor);

/* Continuation
 ******************************************************************************/
var cont = \f, args -> {
    var c = [f, args];
    c._next = true;
    return c;
};

var trampoline = \f -> {
    var value = f;
    while (value && value._next)
        value = value[0].apply(undefined, value[1]);
    return value;
};

/* State
 ******************************************************************************/
var State = function(realScope, scope) {
    this.realScope = realScope;
    this.scope = scope;
};

State.setScope = \s, scope ->
    new State(s.realScope, scope);

State.setRealScope = \s, realScope ->
    new State(realScope, s.scope);

/*
 ******************************************************************************/
var ok = \x -> \s, ok, err -> ok(x, s);

var error = \x -> \s, ok, err -> err(x, s);

var bind = \p, f -> \s, ok, err -> cont(p, [s, \x, s -> f(x)(s, ok, err), err]);

var next = \p, n -> bind(p, \() -> n);

var seq = \arr -> reduceRight(arr, \p, c -> next(c, p), ok());

var extract = \s, ok, err -> ok(s, s);

var examineScope = \f -> bind(extract, \s -> f(s.scope));

var examineRealScope = \f -> bind(extract, \s -> f(s.realScope));

var modifyScope = \f ->
    \s, ok, err -> let
        scope = f(s.scope),
        newState = State.setScope(s, scope)
    in ok(scope, newState);
    
var modifyRealScope = \f ->
    \s, ok, err -> let
        scope = f(s.realScope),
        newState = State.setRealScope(s, scope)
    in ok(scope, newState);
    
var setScope = \s -> modifyScope(\() -> s);

var setRealScope = \s -> modifyRealScope(\() -> s);

/* RealScope
 ******************************************************************************/
/**
 * Holds information about a lexical scope.
 * 
 * @param record Maps identifiers to binding information for this scope.
 * @param outer Parent scope.
 * @param mappin Maps identifiers to their actual names in this scope.
 */
var Scope = function(record, outer, mapping) {
    this.record = record;
    this.outer = outer;
    this.mapping = mapping;
};

/**
 * Does this scope have a given binding?
 */
Scope.prototype.hasOwnBinding = \id ->
    Object.prototype.hasOwnProperty.call(this.record, id);

/**
 * Does this scope or its parents have a given binding?
 */
Scope.prototype.hasBinding = \id ->
    this.hasOwnBinding(id) || (this.outer && this.outer.hasBinding(id));

/**
 * Get information for a given binding. Returns null if binding does not exist.
 */
Scope.prototype.getBinding = \id ->
    this.hasOwnBinding(id) ?
        this.record[id] :
        (this.outer ? this.outer.getBinding(id) : null);

/**
 * Does this scope have a mapping for a given identifier.
 */
Scope.prototype.hasMapping = \id ->
    Object.prototype.hasOwnProperty(this.mapping, id) || (this.outer && this.outer.hasMapping(id));

/**
 * Get the mapped value for a given identifier.
 */
Scope.prototype.getMapping = \id ->
    (this.mapping.hasOwnProperty(id) ?
        this.mapping[id] :
        this.outer && this.outer.getMapping(id));

/**
 * Get an unused identifier in this scope.
 */
Scope.prototype.getUnusedId = \id -> {
    if (!this.hasBinding(id))
        return id;
    for (var i = 0; ; i = i + 1)
        if (!this.hasBinding(id + i))
            return id + i;
};

/**
 * Create a new modified scope with a given binding.
 * 
 * @param s Scope.
 * @param id Identifier for new binding.
 * @param info Binding information.
 */
Scope.addBinding = \s, id, info ->
    new Scope(
        defineProperty(s.record, id, {
            'value': info,
            'enumerable': true,
            'writable': true,
            'configurable': true
        }),
        s.outer,
        s.mapping);

/**
 * Create a new modified scope with a new mutable binding.
 * 
 * @s Scope
 * @param id Identifier for new binding
 * @param loc Location of binding in source code.
 */
Scope.addMutableBinding = \s, id, loc ->
    Scope.addBinding(s, id, {
        'mutable': true,
        'loc': loc
    });

/**
 * Create a new modified scope with a new immutable binding.
 * 
 * @s Scope
 * @param id Identifier for new binding
 * @param loc Location of binding in source code.
 */
Scope.addImmutableBinding = \s, id, loc ->
    Scope.addBinding(s, id, {
        'mutable': false,
        'loc': loc
    });

/**
 * Create a new modified scope with a new mapping
 * 
 * @s Scope
 * @param from Key value.
 * @param to Value to map to.
 */
Scope.addMapping = \s, from, to ->
    new Scope(
        s.record,
        s.outer,
        defineProperty(s.mapping, from, {
            'value': to,
            'enumerable': true,
            'writable': true,
            'configurable': true
        }));

/* Operations
 ******************************************************************************/
/**
 * Create a new lexical block for body.
 */
var block = \body ->
    examineScope(\s ->
        seq([
            setScope(new Scope({}, s, s.mapping)),
            body,
            setScope(s)]));
    
/**
 * Create a new lexical block for body.
 */
var emptyBlock = \body ->
    examineScope(\s ->
        seq([
            setScope(new Scope({}, s, {})),
            body,
            setScope(s)]));

/**
 * Create a new lexical block for body.
 */
var realBlock = \body ->
    examineRealScope(\s ->
        seq([
            setRealScope(new Scope({}, s, {})),
            emptyBlock(body),
            setRealScope(s)]));

/**
 * Test to see if the current scope already contains a binding for id.
 */
var checkCanAddOwnBinding = \id, loc -> 
    examineScope(\s -> s.hasOwnBinding(id) ?
        error("'" + id + "' at:" + loc + " already bound for scope from:" + s.getBinding(id).loc) :
        ok());

var hasBinding = \id, loc ->
    examineScope(\s -> s.hasBinding(id) ?
        ok() :
        error("Undeclared identifier:'" + id + "' at:" + loc));

/**
 * 
 */
var checkCanAssign = \id, loc -> 
    examineScope(\s -> s.hasBinding(id) ?
        let b = s.getBinding(id) in
            b.mutable ? ok() : error("Assign to immutable variable:'" + id + "' at:"+ loc) :
        ok());

var addMapping = \id, newId ->
    modifyScope(\s -> Scope.addMapping(s, id, newId));

/**
 * Adds a new mutable binding in the current scope. Does not perform any checks.
 */
var addMutableBinding = \id, loc -> 
    seq([
         modifyScope(\s -> Scope.addMutableBinding(s, id, loc)),
         modifyRealScope(\s -> Scope.addMutableBinding(s, id, loc)),
         addMapping(id, id)]);

/**
 * Adds a new immutable binding in the current scope. Does not perform any checks.
 */
var addImmutableBinding = \id, loc -> 
    seq([
         modifyScope(\s -> Scope.addImmutableBinding(s, id, loc)),
         modifyRealScope(\s -> Scope.addImmutableBinding(s, id, loc)),
         addMapping(id, id)]);

/**
 * Adds a new, and unique, mutable binding in the current scope. Does not perform any checks.
 */
var addUniqueMutableBinding = \id, loc ->
    next(
        checkCanAddOwnBinding(id, loc),
        examineRealScope(\s -> s.hasOwnBinding(id) ?
            let new_id = s.getUnusedId(id) in
                seq([
                     addMutableBinding(id, loc),
                     addMutableBinding(new_id, loc),
                     addMapping(id, new_id)]) :
            addMutableBinding(id, loc)));

/**
 * 
 */
var addMutableBindingInRealBlock = \id, loc ->
    next(
        checkCanAddOwnBinding(id, loc),
        addUniqueMutableBinding(id, loc));

var addImmutableBindingInRealBlock = \id, loc ->
    next(
        checkCanAddOwnBinding(id, loc),
        addImmutableBinding(id, loc));

var addUniqueImmutableBinding = \id, loc -> seq([
    checkCanAddOwnBinding(id, loc),
    examineRealScope(\s -> s.hasOwnBinding(id) ?
        let new_id = s.getUnusedId(id) in
            seq([
                addImmutableBinding(id, loc),
                addImmutableBinding(new_id, loc),
                addMapping(id, new_id)]):
        addImmutableBindingInRealBlock(id, loc))]);

/*
 ******************************************************************************/
var _check = function(node) {
    if (!node || !(node instanceof ast_node.Node))
        return ok();
    
    switch (node.type)
    {
// Statement
    case 'BlockStatement':
        return block(
            seq(map(node.body, _check)));
    
    case 'ExpressionStatement':
        return _check(node.expression);
    
    case 'IfStatement':
        return seq([
            _check(node.test),
            block(_check(node.consequent)),
            block(_check(node.alternate))]);
        
    case 'WithStatement':
        return block(
            next(
                seq(node.bindings.map(_check)),
                seq(map(node.body.body, _check))));
        
    case 'SwitchStatement':
        return block(
            next(
                _check(node.discriminant),
                seq(map(node.cases, _check))));
    
    case'ReturnStatement':
        return _check(node.argument);
    
    case 'ThrowStatement':
        return _check(node.argument);
    
    case 'TryStatement':
        return seq([
            _check(node.block),
            block(_check(node.handler)),
            block(_check(node.finalizer))]);
    
    case 'WhileStatement':
        return next(
            _check(node.test),
            block(_check(node.body)));
    
    case 'DoWhileStatement':
        return seq([
            block(_check(node.body)),
            block(_check(node.test))]);
    
    case 'ForStatement':
        return block(seq([
            _check(node.init),
            _check(node.test),
            _check(node.update),
            block(_check(node.body))]));
    
// Expression
    case 'UnaryExpression':
        return _check(node.argument);
    
     case 'AssignmentExpression':
        return seq([
            _check(node.left),
            (node.left.type === 'Identifier' ?
                checkCanAssign(node.left.name, node.left.loc.start) :
                ok()),
            _check(node.right)]);
    
    case 'LogicalExpression':
    case 'BinaryExpression':
        return seq([
            _check(node.left),
            _check(node.right)]);
    
    case 'ConditionalExpression':
        return seq([
            _check(node.test),
            _check(node.consequent),
            _check(node.alternate)]);
    
    case 'CallExpression':
    case 'NewExpression':
        return seq([
            _check(node.callee),
            seq(map(node.args, _check))]);
    
    case 'MemberExpression':
        return seq([
            _check(node.object),
            (node.computed ? _check(node.property) : ok())]);
        
    case 'ArrayExpression':
        return seq(map(node.elements, _check));
    
    case 'ObjectExpression':
        return seq(map(node.properties, \x -> _check(x.value)));
    
    case 'LetExpression':
        return realBlock(
            next(
                seq(node.bindings.map(_check)),
                _check(node.body)));
    
    case 'CurryExpression':
        return next(
            _check(node.base),
            seq(map(node.args, _check)));
        
    case 'UnaryOperatorExpression':
        return ok();
    
// Function
    case 'FunctionExpression':
        return realBlock(
            seq([
                 (node.id ? addImmutableBinding(node.id.name, node.loc) : ok()),
                 _check(node.params),
                 seq(map(node.body.body, _check))]));

// Program
    case 'Program':
        return Array.isArray(node.body) ?
            seq(map(node.body, _check)) :
            _check(node.body);

// Package
    case 'Package':
        return seq([
            addImmutableBindingInRealBlock('require', null),
            addImmutableBindingInRealBlock('exports', null),
            addImmutableBindingInRealBlock('module', null),
            _check(node.exports),
            (node.body.type === 'WithStatement' ?
                next(
                    seq(map(node.body.bindings, _check)),
                    seq(map(node.body.body.body, _check))) :
                seq(map(node.body.body, _check)))]);
        
    case 'PackageExports':
        return seq(map(node.exports, _check));
    
    case 'PackageExport':
        return addMutableBindingInRealBlock(node.id.name, node.loc);

// Clause
    case 'CatchClause':
        return block(
            next(
                addImmutableBindingInRealBlock(node.param.name, node.param.loc),
                seq(map(node.body.body, _check))));
    
    case 'SwitchCase':
        return seq(map(node.consequent, _check));
    
// Declarations
    case 'StaticDeclaration':
    case 'VariableDeclaration':
        return seq(map(node.declarations, _check));
    
    case 'StaticDeclarator':
        return addImmutableBindingInRealBlock(node.id.name, node.loc);
        
    case 'VariableDeclarator':
        return seq([
            addMutableBindingInRealBlock(node.id.name, node.loc),
            _check(node.id),
            _check(node.init)]);
        
    case 'Binding': 
        return next(
            _check(node.pattern),
            _check(node.value));
        
    
// Pattern
    case 'EllipsisPattern':
        return ok();
        
    case 'IdentifierPattern':
        return seq([
            addUniqueImmutableBinding(node.id.name, node.loc),
            _check(node.init),
            examineScope(\s -> {
                if (s.hasMapping(node.id.name))
                    node.id.name = s.getMapping(node.id.name);
                return ok();
            })]);
        
    case 'ImportPattern':
        return _check(node.pattern);
    
    case 'ArrayPattern':
        return examineScope(\s -> {
            if (!node.id) {
                var id = ast_pattern.IdentifierPattern.create(null,
                    ast_value.Identifier.create(null, s.getUnusedId('__a')));
                id.gen = true;
                node.id = id;
            }
            return next(
                _check(node.id),
                seq(map(node.elements, _check)));
        });
    
    case 'ObjectPattern':
        return examineScope(\s -> {
            if (!node.id) {
                var id = ast_pattern.IdentifierPattern.create(null,
                    ast_value.Identifier.create(null, s.getUnusedId('__o')));
                id.gen = true;
                node.id = id;
            }
            return next(
                _check(node.id),
                seq(map(
                    node.elements,
                    _check)));
        });
    
    case 'ObjectPatternElement':
        return (node.target ?
            _check(node.target) :
            _check(node.key));
        
    case 'ArgumentsPattern':
        return next(
            _check(node.id),
            seq(map(node.elements, _check)));
    
// Value
    case 'Identifier':
        return examineScope(\s -> {
            if (s.hasMapping(node.name))
                node.name = s.getMapping(node.name);
            return hasBinding(node.name, node.loc);
        });
    }
    
    return ok();
};

var builtins = [
    'Array',
    'Boolean',
    'Date',
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'Error',
    'eval',
    'EvalError',
    'Function',
    'Infinity',
    'isFinite',
    'isNaN',
    'JSON',
    'Math',
    'NaN',
    'Number',
    'Object',
    'parseInt',
    'parseFloat',
    'RangeError',
    'ReferenceError',
    'RegExp',
    'String',
    'SyntaxError',
    'TypeError',
    'undefined',
    'URIError'];

check = function(root, globals) {
    var g = globals || builtins;
    var scope = g.reduce(Scope.addImmutableBinding, new Scope({}, null, {}));
    var state = new State(scope, scope);
    return trampoline(_check(root)(state, \x -> root, \err, s -> { throw err; }));
};

}