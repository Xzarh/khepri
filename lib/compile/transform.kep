/**
 * @fileOverview
 * 
 * @TODO Better data structure (Zipper?) and eliminate mutation.
 */
static define;
define(['ecma_ast/clause',
        'ecma_ast/declaration',
        'ecma_ast/expression',
        'ecma_ast/node',
        'ecma_ast/program',
        'ecma_ast/statement',
        'ecma_ast/value',
        'khepri_ast/clause',
        'khepri_ast/declaration',
        'khepri_ast/expression',
        'khepri_ast/node',
        'khepri_ast/pattern',
        'khepri_ast/program',
        'khepri_ast/statement',
        'khepri_ast/value'],
function(ecma_clause,
        ecma_declaration,
        ecma_expression,
        ecma_node,
        ecma_program,
        ecma_statement,
        ecma_value,
        khepri_clause,
        khepri_declaration,
        khepri_expression,
        khepri_node,
        khepri_pattern,
        khepri_program,
        khepri_statement,
        khepri_value){
//"use strict";

var concat = Function.prototype.call.bind(Array.prototype.concat);
var map = Function.prototype.call.bind(Array.prototype.map);
var reduce = Function.prototype.call.bind(Array.prototype.reduce);

var flatten = \x -> reduce(x, \p, c -> p.concat(c), []);

/* Pattern
 ******************************************************************************/
var arrayPattern;

/**
 */
var objectPattern = \base, pattern, key, f -> {
    if (key.type === 'IdentifierPattern' )
        debugger;
    
    var k = (key.type === 'IdentifierPattern' ?
        khepri_value.Literal.create(null, 'string', key.id.name) :
        key);
    
    var innerBase = khepri_expression.MemberExpression.create(null, base, k, true);

    if (!pattern)
        return f(
            khepri_value.Identifier.create(null, k.value),
            innerBase);
    
    
    switch (pattern.type){
    case 'IdentifierPattern':
        return f(
            khepri_value.Identifier.create(null, pattern.id.name),
            innerBase);
    
    case 'ArrayPattern':
        var elements = map(pattern.elements, \x, i -> arrayPattern(innerBase, x, i));
        return (pattern.id.gen ? elements : 
            concat(
                [f(pattern.id, innerBase)],
                elements));
    
    case 'ObjectPattern':
        var elements2 = reduce(
            pattern.elements,
            \p, c ->
                let val = objectPattern(innerBase, c.target, c.key) in (val ? concat(p, val) : p),
            []);
        return (pattern.id.gen ? elements2 : 
            concat(
                [f(pattern.id, innerBase)],
                elements2));
    default:
        return null;
    }
};

/**
 */
var objectDeclPattern = let
    make = \l, r -> khepri_declaration.VariableDeclarator.create(null, l, r)
in
    \base, pattern, key ->
        objectPattern(base, pattern, key, make);

/**
 */
var objectAssignmentPattern = let
    make = \l, r ->
        ecma_statement.ExpressionStatement.create(null,
            ecma_expression.AssignmentExpression.create(null, '=', l, r))
in
    \base, pattern, key ->
        objectPattern(base, pattern, key, make);

/**
 * Generate the prefix for an array pattern.
 */
arrayPattern = \base, pattern, index -> {
    return objectDeclPattern(base, pattern, khepri_value.Literal.create(null, 'number', index));
};

/* Transform
 ******************************************************************************/
var transform = function(node) {
    if (!node || !(node instanceof khepri_node.Node))
        return node;
    
    switch (node.type)
    {
// clause
    case 'CatchClause':
        return new ecma_clause.CatchClause(node.loc,
            transform(node.param),
            transform(node.body));
    
    case 'SwitchCase':
        return new ecma_clause.SwitchCase(node.loc,
            transform(node.test),
            map(node.consequent, transform));
        
// Statement
    case 'BlockStatement':
        return new ecma_statement.BlockStatement(node.loc,
            map(node.body, transform));
    
    case 'ExpressionStatement':
        return new ecma_statement.ExpressionStatement(node.loc,
            transform(node.expression));
    
    case 'IfStatement':
        return new ecma_statement.IfStatement(node.loc,
            transform(node.test),
            transform(node.consequent),
            transform(node.alternate));
        
    case 'WithStatement':
        var bindings = reduce(node.bindings, \p, imp -> {
            var base = imp.value;
            
            if (imp.type === 'ImportPattern') {
                var base = ecma_expression.CallExpression.create(null,
                    ecma_value.Identifier.create(null, 'require'),
                    [imp.from]);
                switch (imp.pattern.type) {
                case 'IdentifierPattern':
                    return concat(
                        p,
                        khepri_declaration.VariableDeclarator.create(null,
                            imp.pattern,
                            base));
                 case 'ObjectPattern':
                     var b = khepri_value.Identifier.create(null, imp.from.name);
                     return concat(
                         p,
                        ecma_declaration.VariableDeclarator.create(null, transform(imp.pattern.id), base),
                        reduce(imp.pattern.elements, \p, c ->
                            let val = objectDeclPattern(transform(imp.pattern.id), c.target, c.key) in (val ? concat(p, val) : p),
                            []));
                }
                return p;
            }
            switch (imp.pattern.type) {
            case 'IdentifierPattern':
                return concat(
                    p,
                    khepri_declaration.VariableDeclarator.create(null,
                        imp.pattern,
                        base));
            
             case 'ObjectPattern':
                 return concat(
                     p,
                    khepri_declaration.VariableDeclarator.create(null, imp.pattern.id, base),
                    flatten(
                        map(imp.pattern.elements, \c ->
                            objectDeclPattern(imp.pattern.id, c.target, c.key))));
             
            case 'ArrayPattern':
                return concat(
                    p,
                    khepri_declaration.VariableDeclarator.create(null, imp.pattern.id, base),
                    flatten(
                        map(imp.pattern.elements, \c, i ->
                            arrayPattern(imp.pattern.id, c, i))));
            }
            return p;
        }, []);
        
        var prefix = (bindings.length ?
            khepri_declaration.VariableDeclaration.create(null, bindings) :
            []);
        
        return transform(
            khepri_statement.BlockStatement.create(node.body.loc,
                concat(
                    prefix,
                    node.body)));

    case 'SwitchStatement':
        return new ecma_statement.SwitchStatement(node.loc,
            transform(node.discriminant),
            map(node.cases, transform));
    
    case'ReturnStatement':
        return new ecma_statement.ReturnStatement(node.loc,
            transform(node.argument));
    
    case 'ThrowStatement':
        return new ecma_statement.ThrowStatement(node.loc,
            transform(node.argument));
    
    case 'TryStatement':
        return new ecma_statement.TryStatement(node.loc,
            transform(node.block),
            transform(node.handler),
            transform(node.finalizer));
    
    case 'WhileStatement':
        return new ecma_statement.WhileStatement(node.loc,
            transform(node.test),
            transform(node.body));
    
    case 'DoWhileStatement':
        return new ecma_statement.DoWhileStatement(node.loc,
            transform(node.body),
            transform(node.test));
    
    case 'ForStatement':
        return new ecma_statement.ForStatement(node.loc,
            transform(node.init),
            transform(node.test),
            transform(node.update),
            transform(node.body));
    
// Expression
    case 'AssignmentExpression':
        return new ecma_expression.AssignmentExpression(node.loc,
            node.operator,
            transform(node.left),
            transform(node.right));
    
    case 'UnaryExpression':
        return new ecma_expression.UnaryExpression(node.loc,
            node.operator,
            transform(node.argument));
    
    case 'BinaryExpression':
        switch (node.operator) {
        case '\\>':
            return transform(
                khepri_expression.CallExpression.create(null,
                    khepri_expression.FunctionExpression.create(node.loc, null,
                        khepri_pattern.ArgumentsPattern.create(null, null, [
                            khepri_pattern.IdentifierPattern.create(null,
                                khepri_value.Identifier.create(null, 'f')),
                            khepri_pattern.IdentifierPattern.create(null,
                                khepri_value.Identifier.create(null, 'g'))]),
                    khepri_statement.BlockStatement.create(null, [
                        khepri_statement.ReturnStatement.create(null, 
                            khepri_expression.FunctionExpression.create(node.loc, null,
                                khepri_pattern.ArgumentsPattern.create(null, null, []),
                                khepri_statement.BlockStatement.create(null, [
                                    khepri_statement.ReturnStatement.create(null,
                                        khepri_expression.CallExpression.create(null,
                                            khepri_value.Identifier.create(null, 'g'), [
                                                khepri_expression.CallExpression.create(null,
                                                     khepri_expression.MemberExpression.create(null,
                                                         khepri_value.Identifier.create(null, 'f'),
                                                         khepri_value.Identifier.create(null, 'apply')),
                                                     [khepri_value.Literal.create(null, 'null', null),
                                                     khepri_value.Identifier.create(null, 'arguments')])]))])))])), [
                    node.left,
                    node.right]));
            
        case '|>':
            return transform(
                khepri_expression.CallExpression.create(null,
                    node.right,
                    [node.left]));
        
        default:
            return ecma_expression.BinaryExpression.create(node.loc,
                node.operator,
                transform(node.left),
                transform(node.right));
        }
    
    case 'LogicalExpression':
        return new ecma_expression.LogicalExpression(node.loc,
            node.operator,
            transform(node.left),
            transform(node.right));
    
    case 'ConditionalExpression':
        return new ecma_expression.ConditionalExpression(node.loc,
            transform(node.test),
            transform(node.consequent),
            transform(node.alternate));
    
    case 'NewExpression':
        return ecma_expression.NewExpression.create(node.loc,
            transform(node.callee),
            map(node.args, transform));
    
    case 'CallExpression':
        return ecma_expression.CallExpression.create(node.loc,
            transform(node.callee),
            node.args.map(transform));
    
    case 'MemberExpression':
        return ecma_expression.MemberExpression.create(node.loc,
            transform(node.object),
            transform(node.property),
            node.computed);
        
    case 'ArrayExpression':
        return ecma_expression.ArrayExpression.create(node.loc,
            map(node.elements, transform));
    
    case 'ObjectExpression':
        return ecma_expression.ObjectExpression.create(node.loc,
            map(node.properties, \x -> ({
                'kind': x.kind,
                'key': transform(x.key),
                'value': transform(x.value)
            })));
    
    case 'LetExpression':
        return transform(
             khepri_expression.CallExpression.create(node.loc,
                khepri_expression.FunctionExpression.create(null,
                    null,
                    khepri_pattern.ArgumentsPattern.create(null, null, []),
                    khepri_statement.BlockStatement.create(null, [
                         khepri_statement.WithStatement.create(null,
                             node.bindings,
                             khepri_statement.BlockStatement.create(null, [
                                 khepri_statement.ReturnStatement.create(null, node.body)]))])),
                []));
    
    case 'CurryExpression':
        return (node.args.length === 0 ?
            transform(node.base) :
            transform(
                khepri_expression.CallExpression.create(null,
                    khepri_expression.MemberExpression.create(null,
                        transform(node.base),
                        khepri_value.Identifier.create(null, 'bind')),
                    concat(
                        khepri_value.Literal.create(null, 'null', null),
                        map(node.args, transform)))));
    
    case 'UnaryOperatorExpression':
         return transform(
             khepri_expression.FunctionExpression.create(node.loc, null,
                khepri_pattern.ArgumentsPattern.create(null, null, [
                    khepri_pattern.IdentifierPattern.create(null,
                        khepri_value.Identifier.create(null, 'x'))]),
            khepri_statement.BlockStatement.create(null, [
                khepri_statement.ReturnStatement.create(null, 
                    khepri_expression.UnaryExpression.create(null,
                        node.op,
                        khepri_value.Identifier.create(null, 'x')))])));
         
    case 'BinaryOperatorExpression':
        var kind = (node.op === '||' || node.op === '&&' ?
            khepri_expression.LogicalExpression :
            khepri_expression.BinaryExpression);
        
        return transform(
             khepri_expression.FunctionExpression.create(node.loc, null,
                khepri_pattern.ArgumentsPattern.create(null, null, [
                    khepri_pattern.IdentifierPattern.create(null,
                        khepri_value.Identifier.create(null, 'x')),
                    khepri_pattern.IdentifierPattern.create(null,
                        khepri_value.Identifier.create(null, 'y'))]),
            khepri_statement.BlockStatement.create(null, [
                khepri_statement.ReturnStatement.create(null, 
                    kind.create(null,
                        node.op,
                        khepri_value.Identifier.create(null, 'x'),
                        khepri_value.Identifier.create(null, 'y')))])));
    
    case 'BinaryOperatorExpression':
        return transform(
             khepri_expression.FunctionExpression.create(node.loc, null,
                khepri_pattern.ArgumentsPattern.create(null, null, [
                    khepri_pattern.IdentifierPattern.create(null,
                        khepri_value.Identifier.create(null, 'x')),
                    khepri_pattern.IdentifierPattern.create(null,
                        khepri_value.Identifier.create(null, 'y')),
                        khepri_pattern.IdentifierPattern.create(null,
                        khepri_value.Identifier.create(null, 'z'))]),
            khepri_statement.BlockStatement.create(null, [
                khepri_statement.ReturnStatement.create(null, 
                    khepri_expression.ConditionalExpression.create(null,
                        khepri_value.Identifier.create(null, 'x'),
                        khepri_value.Identifier.create(null, 'y'),
                        khepri_value.Identifier.create(null, 'z')))])));
// Function
    case 'FunctionExpression':
        return let
            params = reduce(transform(node.params.elements), \p, c -> {
                if (!c || c.type === 'EllipsisPattern')
                    return p;
                return p.concat([transform(c)]);
            }, []),
            
            
            prefix = reduce(node.params.elements, \p, c -> {
                var base;
                switch (c.type) {
                case 'ArrayPattern':
                    base = transform(c.id);
                    return concat(p, khepri_declaration.VariableDeclaration.create(null,
                        reduce(c.elements, \p, c, i ->
                            let val = arrayPattern(base, c, i) in (val ? concat(p, val) : p),
                            [])));
                 case 'ObjectPattern':
                    base = transform(c.id);
                    return concat(p, khepri_declaration.VariableDeclaration.create(null,
                        reduce(c.elements, \p, c ->
                            let val = objectDeclPattern(base, c.target, c.key) in (val ? concat(p, val) : p),
                            [])));
                }
                return p;
            }, (node.params.id ?
                [khepri_declaration.VariableDeclaration.create(null, [
                    khepri_declaration.VariableDeclarator.create(null,
                        transform(node.params.id),
                        khepri_value.Identifier.create(null, 'arguments'))])] :
                []))
    in
        ecma_expression.FunctionExpression.create(node.loc,
            transform(node.id),
            params,
            transform(khepri_statement.BlockStatement.create(node.body.loc,
                concat(prefix, node.body.body))));
    
// Patterns
    case 'ArgumentsPattern':
        return new ecma_value.Identifier(node.loc, node.id.name);
    
    case 'IdentifierPattern':
        return new ecma_value.Identifier(node.loc, node.id.name);
    
    case 'ArrayPattern':
    case 'ObjectPattern':
        return transform(node.id);
    
    case 'EllipsisPattern':
        return null;
    
// Program
    case 'Program':
        return ecma_program.Program.create(node.loc,
            Array.isArray(node.body) ?
                map(node.body, transform) :
                [transform(node.body)]);
// Package
    case 'Package':
        var imp = (node.body.type === 'WithStatement' ?
            node.body.bindings.filter(\x -> x.type === 'ImportPattern') :
            []);
        
        var imports = map(imp, \x -> x.from);
        
        var exports = map(node.exports.exports, \x -> x.id);
        
        var exportHeader = ecma_declaration.VariableDeclaration.create(null,
            exports.map(\x -> ecma_declaration.VariableDeclarator.create(null, x)));
        
        var exportBody = exports.map(\x ->
            ecma_statement.ExpressionStatement.create(null,
                ecma_expression.AssignmentExpression.create(null, '=',
                    ecma_expression.MemberExpression.create(null,
                        ecma_value.Identifier.create(null, 'exports'),
                        ecma_value.Identifier.create(null, x.name)),
                    ecma_value.Identifier.create(null, x.name))));
        
        var fBody = transform(node.body.type === 'WithStatement' ?
            khepri_statement.WithStatement.create(null,
                node.body.bindings.map(\x -> (x.type !== 'ImportPattern' ? x :
                    khepri_declaration.Binding.create(null,
                        x.pattern,
                        x.pattern.id))),
                node.body.body) :
            node.body);
        
        var body = ecma_expression.FunctionExpression.create(null, null,
                concat(
                    ecma_value.Identifier.create(null, 'require'),
                    ecma_value.Identifier.create(null, 'exports'),
                    imp.map(\x -> transform(x.pattern.id))),
            ecma_statement.BlockStatement.create(fBody.loc, concat(
                ecma_statement.ExpressionStatement.create(null,
                    ecma_value.Literal.create(null, 'string', "use strict")),
                exportHeader,
                fBody.body,
                exportBody)));
        
        return ecma_expression.CallExpression.create(node.loc,
            ecma_value.Identifier.create(null, 'define'),
            [ecma_expression.ArrayExpression.create(null,
                concat(
                    ecma_value.Literal.create(null, 'string', 'require'),
                    ecma_value.Literal.create(null, 'string', 'exports'),
                    imports)),
                body]);
        
// Declarations
    case 'VariableDeclaration':
        return new ecma_declaration.VariableDeclaration(node.loc,
            map(node.declarations, transform));
        
    case 'VariableDeclarator':
        return new ecma_declaration.VariableDeclarator(node.loc,
            transform(node.id),
            transform(node.init));
        
    case 'StaticDeclaration':
        return new ecma_statement.EmptyStatement(node.loc);
    }
    
    return node;
};

/* Export
 ******************************************************************************/
return {
    'transform': transform
};

});