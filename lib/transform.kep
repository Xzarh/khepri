/**
 * @fileOverview
 * 
 * @TODO Better data structure (Zipper?) and eliminate mutation.
 */
package (
    transform)
with 
    import 'bes::record' record,
    
    import 'ecma-ast::clause' ecma_clause,
    import 'ecma-ast::declaration' ecma_declaration,
    import 'ecma-ast::expression' ecma_expression,
    import 'ecma-ast::node' ecma_node,
    import 'ecma-ast::program' ecma_program,
    import 'ecma-ast::statement' ecma_statement,
    import 'ecma-ast::value'ecma_value,
    
    import 'khepri-ast::clause' khepri_clause,
    import 'khepri-ast::declaration' khepri_declaration,
    import 'khepri-ast::expression' khepri_expression,
    import 'khepri-ast::node' khepri_node#{setUserData Node modify},
    import 'khepri-ast::pattern' khepri_pattern,
    import 'khepri-ast::program' khepri_program,
    import 'khepri-ast::statement' khepri_statement,
    import 'khepri-ast::value' khepri_value,
    
    import 'nu-stream::stream' stream#{foldl from NIL},
    import 'khepri-ast-zipper' khepri_zipper,

    import 'neith::tree' tree#{treeZipper},
    import 'neith::walk' zipper_walk#{preWalk postWalk},
        
    import './scope' scope,
    import './package_manager::amd' _,
    import './package_manager::node' _
in {

var concat = Function.prototype.call.bind(Array.prototype.concat);
var reduce = Function.prototype.call.bind(Array.prototype.reduce);
var reduceRight = Function.prototype.call.bind(Array.prototype.reduceRight);

var filter = \f, a -> Array.prototype.filter.call(a, f);
var map = \f, a ->  Array.prototype.map.call(a, f);

var id = \x -> x;

var flatten = \x ->
    ?Array.isArray(x)
        :reduce(x, \p, c -> p.concat(c), [])
        :x;

/**
 * Is an array of source elements strict code?
 */
var isStrict = \elems -> {
    if (elems && elems.length && elems.(0).type === 'ExpressionStatement') {
        var first = elems.(0).expression;
        return (first && first.type === 'Literal' && first.kind ==='string' && first.value === 'use strict');
    }
    return false;
};

var State = record.declare(null, [
    'node',
    'scope',
    'packageManager']);

State.empty = State.create(null, scope.Scope.empty, null);

var next = \a b -> \ctx -> b(a(ctx));

var seqa = \arr -> reduceRight(arr, \p, c -> next(c, p));

var seq = \args(...) -> seqa(args);

var examineScope = \f ->
    \ctx ->
       f(tree.node(ctx).scope)(ctx);

var setScope = \s -> tree.modifyNode @ (\state -> state.setScope(s));

var enterBlock = examineScope(\s ->
    setScope(new scope.Scope({}, s, {}, {})));

var exitBlock = examineScope(\s ->
    setScope(s.parent));

var modifyNode = \f ctx ->
    tree.modifyNode(
         \s ->
             s.setNode(f(s.node)),
         ctx);

var addVar = \id uid ->
    examineScope(\s ->
        ?s.hasMapping(uid)
            :id
            :let name = s.getUnusedId(id) in
                setScope(scope.Scope.addMapping(
                    scope.Scope.addMutableBinding(s, name),
                    uid,
                    name)));

var getMapping = \uid ->
    \ctx ->
        tree.node(ctx).scope.getMapping(uid);

var khepriZipper = treeZipper@(
    \ctx ->
        khepri_zipper.getChildren(ctx.node),
    \ctx, key ->
        ctx.setNode(khepri_zipper.getChild(ctx.node, key)),
    \ctx, pairs, value ->
        ctx.setNode(
            khepri_zipper.construct(
                ctx.node,
                stream.map(\x -> tree.Pair(x.key, x.value.node), pairs),
                \() -> let v = value() in reduce(Object.keys(v), \p c -> { p.(c) = v.(c).node; return p; }, {}))));

        
/* State
 ******************************************************************************/
var _transform;

/* State
 ******************************************************************************/
// @TODO: evil
var packageManager;

/* Values
 ******************************************************************************/
var identifier = \loc, name ->
    ecma_value.Identifier.create(loc, name);

var stringLiteral = \loc, value ->
    ecma_value.Literal.create(loc, 'string', value);

var nullLiteral = \loc ->
    ecma_value.Literal.create(loc, 'null', null);

/* Declaration
 ******************************************************************************/
var variableDeclaration = khepri_declaration.VariableDeclaration.create;

var variableDeclarator = ecma_declaration.VariableDeclarator.create;

/* Unpacks
 ******************************************************************************/
/**
 * Expand a complex binding to a list of identifier bindings.
 * 
 * @param base Value being unpacked.
 * @param pattern Pattern unpacking base value.
 */
var innerPattern = let
    objectElementUnpack = \base, pattern, key -> let
        innerBase = khepri_expression.MemberExpression.create(null, base, key, true)
    in
        ?pattern
            :flatten <| innerPattern(innerBase, pattern)
            :khepri_declaration.Binding.create(null, identifier(null, key.value), innerBase)
in
    \base, pattern -> {
        switch (pattern.type) {
        case 'IdentifierPattern':
            return concat(
                khepri_declaration.Binding.create(null,
                    pattern.id,
                    base));
        
        case 'AsPattern':
            return concat(
                innerPattern(base, pattern.id),
                flatten <| innerPattern(pattern.id, pattern.target));
        
        case 'ObjectPattern':
            return pattern.elements
                |> (map @ \{target key} -> objectElementUnpack(pattern.ud.id, target, key))
                |> flatten;
        
        default:
            return [];
        }
    };

/**
 * 
 */
var unpack = \pattern, value ->
    innerPattern(value, pattern)
        |> flatten
        |> (map @ \x -> variableDeclarator(null, x.pattern, x.value));

/**
 * 
 */
var unpackAssign = \pattern, value ->
    innerPattern(value, pattern)
        |> flatten
        |> (map @ \x -> ecma_expression.AssignmentExpression.create(null,'=', x.pattern, x.value));

/* Statements
 ******************************************************************************/
/**
 * With statement translation.
 */
var withStatement = \loc, bindings, body -> let
    vars = bindings
        |> (map @ \imp ->
            unpack(
                imp.pattern,
                ?imp.type === 'ImportPattern'
                    :packageManager.importPackage(imp.from.value)
                    :imp.value))
        |> flatten,
    
    prefix = variableDeclaration(null, vars)
in
    khepri_statement.BlockStatement.create(loc,
        concat(
            prefix,
            body.body));

/* Expressions
 ******************************************************************************/
/**
 * Function Expression Normalization.
 */
var functionExpression = \loc, id, parameters, functionBody -> let
    params = parameters.elements
        |> (filter@\x -> x.type !== 'EllipsisPattern'),
    
    elementsPrefix = parameters.elements
        |> map@\x -> {
            // Avoid generating redundant unpacks for parameters names.
            switch (x.type) {
            case 'IdentifierPattern':
                return [];
            case 'AsPattern':
                return flatten <| innerPattern(x.id, x.target);
            default:
                return innerPattern(x, x);
            }
        }
        |> flatten
        |> (map @ \x -> variableDeclarator(null, x.pattern, x.value)),
    
    argumentsPrefix = concat(
        ?parameters.self
            :variableDeclarator(null,
                parameters.self,
                ecma_expression.ThisExpression.create(null))
            :[],
        ?parameters.id
            :variableDeclarator(null,
                parameters.id,
                identifier(null, 'arguments'))
            :[]),
    
    body = ?functionBody.type === "BlockStatement"
        :functionBody
        :khepri_statement.BlockStatement.create(null,
            khepri_statement.ReturnStatement.create(null, functionBody)),
    
    strict = isStrict(body.body),
    
    prefix = concat(
        elementsPrefix,
        argumentsPrefix)
in
    khepri_expression.FunctionExpression.create(loc,
        id,
        params,
        khepri_statement.BlockStatement.create(body.loc,
            concat(
                ?strict
                    :khepri_statement.ExpressionStatement.create(null,
                        khepri_value.Literal.create(null, 'string', "use strict"))
                     :[],
                variableDeclaration(null, prefix),
                let block = body.body in
                    ?strict :block.slice(1) :block)));

/**
 * Let expression normalization.
 */
var letExpression = \loc, bindings, body ->
/* ecma_expression.SequenceExpression.create(null,
        concat(
            map(\x -> unpackAssign(x.pattern, x.value), bindings),
            _transform(body)));
 */
    khepri_expression.CallExpression.create(loc,
        khepri_expression.FunctionExpression.create(null,
            null,
            khepri_pattern.ArgumentsPattern.create(null, null, []),
            khepri_statement.BlockStatement.create(null, [
                withStatement(null,
                    bindings,
                    khepri_statement.BlockStatement.create(null, [
                        khepri_statement.ReturnStatement.create(null, body)]))])),
     []);

/**
 * 
 */
var unaryOperatorExpression = \loc op -> 
    khepri_expression.FunctionExpression.create(loc, null,
        khepri_pattern.ArgumentsPattern.create(null, null, [
            khepri_pattern.IdentifierPattern.create(null,
                identifier(null, 'x'))]),
        khepri_expression.UnaryExpression.create(null,
            op,
            identifier(null, 'x')));

/**
 * 
 */
var binaryOperatorExpression = \loc op -> let
    kind = ? op === '||' || op === '&&'
        :khepri_expression.LogicalExpression
        :khepri_expression.BinaryExpression
in
    khepri_expression.FunctionExpression.create(loc, null,
        khepri_pattern.ArgumentsPattern.create(null, null, [
            khepri_pattern.IdentifierPattern.create(null,
                identifier(null, 'x')),
            khepri_pattern.IdentifierPattern.create(null,
                identifier(null, 'y'))]),
        kind.create(null,
            op,
            identifier(null, 'x'),
            identifier(null, 'y')));

/**
 * 
 */
var ternaryOperatorExpression = \loc ->
    khepri_expression.FunctionExpression.create(loc, null,
        khepri_pattern.ArgumentsPattern.create(null, null, [
            khepri_pattern.IdentifierPattern.create(null,
                identifier(null, 'x')),
            khepri_pattern.IdentifierPattern.create(null,
                identifier(null, 'y')),
                khepri_pattern.IdentifierPattern.create(null,
                identifier(null, 'z'))]),
        khepri_expression.ConditionalExpression.create(null,
            identifier(null, 'x'),
            identifier(null, 'y'),
            identifier(null, 'z')));

/**
 * Curry expression translation.
 */
var curryExpression = \loc, base, args ->
    khepri_expression.CallExpression.create(null,
        khepri_expression.MemberExpression.create(null,
            base,
            identifier(null, 'bind')),
        concat(
            nullLiteral(null),
            args));

/**
 * Pipe operator translation.
 */
var pipe = \loc, value, target ->
    khepri_expression.CallExpression.create(loc,
        target,
        [value]);

/**
 * 
 */
var singleCompose = \loc, f, g ->
    khepri_expression.CallExpression.create(loc,
        khepri_expression.FunctionExpression.create(null, null,
            khepri_pattern.ArgumentsPattern.create(null, null, [
                khepri_pattern.IdentifierPattern.create(null,
                    identifier(null, 'f')),
                khepri_pattern.IdentifierPattern.create(null,
                    identifier(null, 'g'))]),
            khepri_expression.FunctionExpression.create(null, null,
                khepri_pattern.ArgumentsPattern.create(null, null, [
                    khepri_pattern.IdentifierPattern.create(null,
                        identifier(null, 'x'))]),
                khepri_expression.CallExpression.create(null,
                    identifier(null, 'f'), [
                        khepri_expression.CallExpression.create(null,
                            identifier(null, 'g'),
                            [identifier(null, 'x')])]))),
        [f, g]);

/**
 * 
 */
var multiCompose = \loc, f, g ->
    khepri_expression.CallExpression.create(loc,
        khepri_expression.FunctionExpression.create(null, null,
            khepri_pattern.ArgumentsPattern.create(null, null, [
                khepri_pattern.IdentifierPattern.create(null,
                    identifier(null, 'f')),
                khepri_pattern.IdentifierPattern.create(null,
                    identifier(null, 'g'))]),
        khepri_expression.FunctionExpression.create(null, null,
            khepri_pattern.ArgumentsPattern.create(null, null, []),
            khepri_expression.CallExpression.create(null,
                identifier(null, 'f'), [
                    khepri_expression.CallExpression.create(null,
                         khepri_expression.MemberExpression.create(null,
                             identifier(null, 'g'),
                             identifier(null, 'apply')),
                         [nullLiteral(null),
                         identifier(null, 'arguments')])]))),
        [f, g]);

/* Package
 ******************************************************************************/
var packageBlock = \loc, exports, body -> let
    imports = ?body.type === 'WithStatement'
        :filter(\x -> x.type === 'ImportPattern', body.bindings)
        :[],
    
    exportedNames = map(\x -> x.id.name, exports.exports),
    
    targets = reduce(imports, \p c -> {
        p.(c.from.value) = c.pattern;
        return p;
    }, {}),
    
    fBody = ?body.type === 'WithStatement'
        :khepri_statement.WithStatement.create(null,
            filter(\x -> x.type !== 'ImportPattern', body.bindings),
            body.body)
        :body
in
    packageManager.definePackage(loc, exportedNames, imports, targets, fBody);

/* Transform
 ******************************************************************************/
var transformers = {};

var addTransform = \type pre post -> {
    var entry = {
        'pre': pre,
        'post': post
    };
    
    transformers.(type) = ?transformers.(type)
        :transformers.(type).concat(entry)
        :[entry];
};

// Declarations
addTransform('VariableDeclaration',
    id,
    modifyNode @ \node ->
        ecma_declaration.VariableDeclaration.create(node.loc,
            node.declarations));

addTransform('VariableDeclarator',
    id,
    modifyNode @ \node ->
        ecma_declaration.VariableDeclarator.create(node.loc,
            node.id,
            node.init));

addTransform('StaticDeclaration',
    modifyNode @ \node ->
        ecma_statement.EmptyStatement.create(node.loc));

// Clauses
addTransform('CatchClause',
    id,
    modifyNode @ \node ->
        ecma_clause.CatchClause.create(node.loc,
            node.param,
            node.body));

addTransform('SwitchCase',
    id,
    modifyNode @ \node ->
        ecma_clause.SwitchCase.create(node.loc,
            node.test,
            node.consequent));

// Statement
addTransform('BlockStatement',
    id,
    modifyNode @ \node ->
        ecma_statement.BlockStatement.create(node.loc,
            node.body));

addTransform('ExpressionStatement',
    id,
    modifyNode @ \node ->
        ecma_statement.ExpressionStatement.create(node.loc,
            node.expression));

addTransform('IfStatement',
    id,
    modifyNode @ \node ->
        ecma_statement.IfStatement.create(node.loc,
            node.test,
            node.consequent,
            node.alternate));

addTransform('WithStatement',
    \ctx ->
        _transform <|
            modifyNode(\node ->
                withStatement(node.loc,
                    node.bindings,
                    node.body),
                ctx));

addTransform('SwitchStatement',
    id,
    modifyNode @ \node ->
        ecma_statement.SwitchStatement.create(node.loc,
            node.discriminant,
            node.cases));

addTransform('ReturnStatement',
    id,
    modifyNode @ \node ->
        ecma_statement.ReturnStatement.create(node.loc,
            node.argument));

addTransform('ThrowStatement',
    id,
    modifyNode @ \node ->
        ecma_statement.ThrowStatement.create(node.loc,
            node.argument));

addTransform('BreakStatement',
    modifyNode @ \node ->
        ecma_statement.BreakStatement.create(node.loc,
            null));

addTransform('ContinueStatement',
    modifyNode @ \node ->
        ecma_statement.ContinueStatement.create(node.loc,
            null));

addTransform('TryStatement',
    id,
    modifyNode @ \node ->
        ecma_statement.TryStatement.create(node.loc,
            node.block,
            node.handler,
            node.finalizer));

addTransform('WhileStatement',
    id,
    modifyNode @ \node ->
        ecma_statement.WhileStatement.create(node.loc,
            node.test,
            node.body));

addTransform('DoWhileStatement',
    id,
    modifyNode @ \node ->
        ecma_statement.DoWhileStatement.create(node.loc,
            node.body,
            node.test));

addTransform('ForStatement',
    id,
    modifyNode @ \node ->
        ecma_statement.ForStatement.create(node.loc,
            node.init,
            node.test,
            node.update,
            node.body));

// Expression
addTransform('AssignmentExpression',
    id,
    modifyNode @ \node ->
        ecma_expression.AssignmentExpression.create(node.loc,
            node.operator,
            node.left,
            node.right));

addTransform('UnaryExpression',
    id,
    modifyNode @ \node -> {
        var op = node.operator;
        switch (op) {
        case '++': op = '+'; break;
        case '--': op = '-'; break;
        }
        
        return ecma_expression.UnaryExpression.create(node.loc,
            op,
            node.argument);
    });

addTransform('BinaryExpression',
    modifyNode @ \node -> {
        switch (node.operator) {
        case '\\>':
            return singleCompose(node.loc, node.right, node.left);
        case '\\>>':
            return multiCompose(node.loc, node.right, node.left);
        case '<\\':
            return singleCompose(node.loc, node.left, node.right);
        case '<<\\':
            return multiCompose(node.loc, node.left, node.right);
        case '|>':
            return pipe(node.loc, node.left, node.right);
        case '<|':
            return pipe(node.loc, node.right, node.left);
        default:
            return node;
        }
    },
    modifyNode @ \node ->
        ecma_expression.BinaryExpression.create(node.loc,
            node.operator,
            node.left,
            node.right));

addTransform('LogicalExpression',
    id,
    modifyNode @ \node ->
        ecma_expression.LogicalExpression.create(node.loc,
            node.operator,
            node.left,
            node.right));

addTransform('ConditionalExpression',
    id,
    modifyNode @ \node ->
        ecma_expression.ConditionalExpression.create(node.loc,
            node.test,
            node.consequent,
            node.alternate));

addTransform('NewExpression',
    id,
    modifyNode @ \node ->
        ecma_expression.NewExpression.create(node.loc,
            node.callee,
            node.args));

addTransform('CallExpression',
    id,
    modifyNode @ \node ->
        ecma_expression.CallExpression.create(node.loc,
            node.callee,
            node.args));

addTransform('MemberExpression',
    id,
    modifyNode @ \node ->
        ecma_expression.MemberExpression.create(node.loc,
            node.object,
            node.property,
            node.computed));

addTransform('LetExpression',
    modifyNode @ \node ->
        letExpression(node.loc,
            node.bindings,
            node.body));

addTransform('CurryExpression',
    modifyNode @ \node ->
        curryExpression(node.loc,
            node.base,
            node.args));

addTransform('UnaryOperatorExpression',
    \ctx ->
        _transform <|
            modifyNode(\node ->
                unaryOperatorExpression(node.loc, node.op),
                ctx));

addTransform('BinaryOperatorExpression',
    \ctx ->
        _transform <|
            modifyNode(\node ->
                binaryOperatorExpression(node.loc, node.op),
                ctx));

addTransform('TernaryOperatorExpression',
    \ctx ->
        _transform <|
            modifyNode(\node ->
                ternaryOperatorExpression(node.loc),
                ctx));

addTransform('FunctionExpression',
    seq(
        enterBlock,
        modifyNode @ \node ->
            functionExpression(node.loc,
                node.id,
                node.params,
                node.body)),
    modifyNode @ \node ->
        ecma_expression.FunctionExpression.create(null,
            node.id,
            node.params,
            node.body));

addTransform('ArrayExpression',
    id,
    modifyNode @ \node ->
        ecma_expression.ArrayExpression.create(node.loc,
            node.elements));

addTransform('ObjectExpression',
    id,
    modifyNode @ \node ->
        ecma_expression.ObjectExpression.create(node.loc,
            node.properties));

addTransform('ObjectValue',
    id,
    modifyNode @ \node ->
        ecma_value.ObjectValue.create(node.loc,
            node.key,
            node.value));

// Patterns
addTransform('ArgumentsPattern',
    id,
    modifyNode @ \node -> node.id);

addTransform('IdentifierPattern',
    id,
    modifyNode @ \node -> node.id);

addTransform('AsPattern',
    id,
    modifyNode @ \node -> node.id);

addTransform('ObjectPattern',
    id,
    modifyNode @ \node -> node.ud.id);

addTransform('EllipsisPattern',
    id,
    modifyNode @ \node -> (node.ud && node.ud.id));

addTransform('SinkPattern',
    id,
    modifyNode @ \node -> (node.ud && node.ud.id));

// Program
addTransform('Program',
    id,
    modifyNode @ \node ->
        ecma_program.Program.create(node.loc,
            ?Array.isArray(node.body)
                :node.body
                :[node.body]));

// Package
addTransform('Package',
    modifyNode @ \node ->
        packageBlock(node.loc,
            node.exports,
            node.body));

// Value
addTransform('Identifier',
    \ctx -> {
        var node = tree.node(ctx).node;
        var s = addVar(node.name, node.ud.uid)(ctx);
        var n = getMapping(node.ud.uid)(s);

        return modifyNode@(\node ->
            identifier(node.loc, n))(addVar(node.name, node.ud.uid)(ctx));
    });

/*
 * 
 *****************************************************************************/
var _trans = \node -> {
    if (!node || !(node instanceof khepri_node.Node))
        return id;
    
    var t = transformers.(node.type);
    
    if (!t || !t.(0).pre) return id;
    return t.(0).pre;
};

var _transp = \node -> {
    if (!node || !(node instanceof khepri_node.Node))
        return id;
    
    var t = transformers.(node.type);
    
    if (!t || !t.(0).post) return id;
    return t.(0).post;
};

_transform = \ctx ->
    _trans(tree.node(ctx).node)(ctx);

var _transformPost = \ctx ->
    _transp(tree.node(ctx).node)(ctx);
    
var walk = zipper_walk.walk@(_transform, _transformPost);

/*
 * 
 *****************************************************************************/
/**
 * 
 */
transform = \ast manager -> {
    // @TODO: Much evil
    with 
        import './package_manager/amd' amd_manager,
        import './package_manager/node' node_manager
    in {
        packageManager = amd_manager;
        if (manager === 'node')
            packageManager = node_manager;

        return tree.node(
            walk(
                khepriZipper(
                    State.create(ast, packageManager)))).node;

    }
};

}