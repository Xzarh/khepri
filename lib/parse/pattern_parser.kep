/**
 * @fileOverview Khepri patterns parsers.
 */
static define;
define(['parse/parse',
        'parse/lang',
        'ecma/parse/common',
        'ecma/parse/token_parser',
        'khepri_ast/pattern',
        'khepri/parse/value_parser'],
function(parse,
        parse_lang,
        ecma,
        token,
        ast_pattern,
        value){
"use strict";

/* Forward
 ******************************************************************************/
var pattern = \... -> pattern.apply(undefined, arguments);


/* Parsers
 ******************************************************************************/
var identifier = parse.Parser('Identifier Pattern',
    parse.bind(
        token.anyIdentifier,
        \x -> parse.always(ast_pattern.IdentifierPattern.create(x.loc, x.value))));

/**
 * 
 */
var ellipsis = parse.Parser('Ellipsis Pattern',
    parse.bind(
        token.punctuator('...'),
        \x -> parse.always(ast_pattern.EllipsisPattern.create(x.loc))));

/**
 * 
 */
var arrayPattern = parse.Parser('Array Pattern',
    ecma.nodea(
        parse.enumeration(
            parse.optional(null, identifier),
            parse_lang.between(token.punctuator('['), token.punctuator(']'),
                parse.eager(parse_lang.sepBy1(token.punctuator(','), pattern)))),
        ast_pattern.ArrayPattern.create));

/**
 * 
 */
var objectKeyPattern = parse.either(
    parse.bind(identifier, \key -> parse.always({
        'key': key
    })),
    parse.binds(
        parse.enumeration(
            value.stringLiteral,
            parse.next(
                token.punctuator(':'),
                pattern)),
        \key, value -> parse.always({
            'key': key,
            'value': value
        })));

/**
 * 
 */
var objectPattern = parse.Parser('Object Pattern',
    ecma.nodea(
        parse.enumeration(
            parse.optional(null, identifier),
            parse_lang.between(token.punctuator('{'), token.punctuator('}'),
                parse.eager(parse_lang.sepBy1(token.punctuator(','), objectKeyPattern)))),
        ast_pattern.ObjectPattern.create));

/**
 * Package Import
 */
var importPattern = parse.Parser('Import Pattern',
    parse.next(
        token.keyword('import'),
        ecma.nodea(
            parse.enumeration(
                value.stringLiteral,
                parse.either(
                    parse.attempt(objectPattern),
                    identifier)),
            ast_pattern.ImportPattern.create)));

/**
 */
pattern = parse.Parser('Pattern',
    parse.choice(
        ellipsis,
        parse.attempt(arrayPattern),
        parse.attempt(objectPattern),
        identifier));


/* Export
 ******************************************************************************/
return {
    'pattern': pattern,
    
    'identifier': identifier,
    'ellipsis': ellipsis,
    'importPattern': importPattern,
    'arrayPattern': arrayPattern,
    'objectPattern': objectPattern
};

});