/**
 * @fileOverview Khepri patterns parsers.
 */
package (
    pattern,
    
    identifierPattern,
    sinkPattern,
    ellipsisPattern,
    importPattern,
    arrayPattern,
    objectPattern,
    argumentsPattern)
with
    import 'parse/parse' {always, attempt, bind, binds, choice, eager, either, enumeration, next, optional, Parser},
    import 'parse/lang' {between, sepBy, sepBy1, then},
    import 'khepri_ast/pattern' ast_pattern,
    import 'khepri/parse/common' {node, nodea},
    import 'khepri/parse/token_parser' {keyword, punctuator},
    import 'khepri/parse/value_parser' {identifier, stringLiteral}
in {

/* Circular
 ******************************************************************************/
pattern = \args(...) -> pattern.apply(undefined, args);

/* Parts
 ******************************************************************************/
var sep = optional(null, punctuator(','));

/* Base Patterns
 ******************************************************************************/
// Identifier Pattern
////////////////////////////////////////
identifierPattern = (Parser, 'Identifier Pattern') <|
    bind(
        identifier,
        \x -> always(ast_pattern.IdentifierPattern.create(x.loc, x)));

// Sink Pattern
////////////////////////////////////////
sinkPattern = (Parser, 'Sink Pattern') <|
    bind(
        keyword('_'),
        \x -> always(ast_pattern.SinkPattern.create(x.loc)));

// Ellipsis Pattern
////////////////////////////////////////
ellipsisPattern = (Parser, 'Ellipsis Pattern') <|
    bind(
        punctuator('...'),
        \x -> always(ast_pattern.EllipsisPattern.create(x.loc)));

/* Unpacks
 ******************************************************************************/
var as = optional(null, then(identifierPattern, punctuator('#')));

// Array Pattern
////////////////////////////////////////
arrayPattern = Parser('Array Pattern',
    nodea(
        enumeration(
            as,
            between(punctuator('['), punctuator(']'),
                eager <| sepBy1(sep, pattern))),
        ast_pattern.ArrayPattern.create));

// Object Pattern
////////////////////////////////////////
var objectPatternElement = either(
    node(
        identifierPattern,
        \loc, key -> ast_pattern.ObjectPatternElement.create(loc, key, null)),
    nodea(
        enumeration(
            stringLiteral,
            next(
                punctuator(':'),
                pattern)),
        ast_pattern.ObjectPatternElement.create));

objectPattern = Parser('Object Pattern',
    nodea(
        enumeration(
            as,
            between(punctuator('{'), punctuator('}'),
                eager <| sepBy1(sep,
                    objectPatternElement))),
        ast_pattern.ObjectPattern.create));

// Import Pattern
////////////////////////////////////////
importPattern = Parser('Import Pattern',
    next(
        keyword('import'),
        nodea(
            enumeration(
                stringLiteral,
                choice(
                    sinkPattern,
                    attempt <| objectPattern,
                    identifierPattern)),
            ast_pattern.ImportPattern.create)));

// Arguments Pattern
////////////////////////////////////////
argumentsPattern = Parser('Arguments Pattern', let
    argumentsPatternElement = choice(
        ellipsisPattern,
        sinkPattern,
        attempt <| arrayPattern,
        attempt <| objectPattern,
        identifierPattern),
    
    elements =
        eager <| sepBy(sep,
            argumentsPatternElement)
in
    either(
        attempt <| nodea(
            enumeration(
                optional(null, identifierPattern),
                between(punctuator('('), punctuator(')'),
                    elements)),
            ast_pattern.ArgumentsPattern.create),
        node(
            elements,
            \loc, elements -> ast_pattern.ArgumentsPattern.create(loc, null, elements))));

// Pattern
////////////////////////////////////////
pattern = Parser('Pattern',
    choice(
        ellipsisPattern,
        sinkPattern,
        importPattern,
        attempt <| arrayPattern,
        attempt <| objectPattern,
        identifierPattern));

}