/**
 * @fileOverview Khepri patterns parsers.
 */
package (
    pattern
    topLevelPattern
    
    identifierPattern
    sinkPattern
    ellipsisPattern
    
    importPattern
    arrayPattern
    objectPattern
    
    argumentList
    argumentsPattern
    
    asPattern)
with
    import 'parse/parse' {always attempt, bind, binds, choice, eager, either, expected enumeration next optional Parser},
    import 'parse/lang' {between sepBy sepBy1 then},
    import 'khepri_ast/pattern' ast_pattern,
    import 'khepri/parse/common' {node nodea},
    import 'khepri/parse/token_parser' {keyword punctuator},
    import 'khepri/parse/value_parser' {identifier stringLiteral}
in {

/* Circular
 ******************************************************************************/
topLevelPattern = \args(...) -> topLevelPattern.apply(undefined, args);

/* Parts
 ******************************************************************************/
var sep = optional(null, punctuator(','));

/* Base Patterns
 ******************************************************************************/
// Identifier Pattern
////////////////////////////////////////
identifierPattern = (Parser, 'Identifier Pattern') <|
    bind(
        identifier,
        \x -> always(ast_pattern.IdentifierPattern.create(x.loc, x)));

// Sink Pattern
////////////////////////////////////////
sinkPattern = (Parser, 'Sink Pattern') <|
    bind(
        keyword('_'),
        \x -> always(ast_pattern.SinkPattern.create(x.loc)));

// Ellipsis Pattern
////////////////////////////////////////
ellipsisPattern = (Parser, 'Ellipsis Pattern') <|
    bind(
        punctuator('...'),
        \x -> always(ast_pattern.EllipsisPattern.create(x.loc)));

/* Unpacks
 ******************************************************************************/
// As Pattern
////////////////////////////////////////
asPattern = (Parser, 'As Pattern') <|
    nodea(
        enumeration(
            attempt <| then(identifierPattern, punctuator('#')),
            topLevelPattern),
        ast_pattern.AsPattern.create);

// Array Pattern
////////////////////////////////////////
arrayPattern = (Parser, 'Array Pattern') <|
    node(
        between(punctuator('['), punctuator(']'),
            eager <| sepBy1(sep, topLevelPattern)
                |> (expected, "array pattern element")),
        ast_pattern.ArrayPattern.create);

// Object Pattern
////////////////////////////////////////
var objectPatternElement = choice(
    nodea(
        enumeration(
            stringLiteral,
            next(
                punctuator(':'),
                topLevelPattern)),
        ast_pattern.ObjectPatternElement.create),
    node(
        asPattern,
        \loc, key -> ast_pattern.ObjectPatternElement.create(loc, key, null)),
    node(
        identifierPattern,
        \loc, key -> ast_pattern.ObjectPatternElement.create(loc, key, null)));

objectPattern = (Parser, 'Object Pattern') <|
    node(
        between(punctuator('{'), punctuator('}'),
            eager <| sepBy1(sep, objectPatternElement)
                |> (expected, "object pattern element")),
        ast_pattern.ObjectPattern.create);

// Import Pattern
////////////////////////////////////////
importPattern = (Parser, 'Import Pattern') <|
    next(
        keyword('import'),
        nodea(
            enumeration(
                stringLiteral,
                choice(
                    sinkPattern,
                    objectPattern,
                    asPattern,
                    identifierPattern)),
            ast_pattern.ImportPattern.create));


/* Patterns
 ******************************************************************************/
// Top Level Pattern
////////////////////////////////////////
topLevelPattern = (Parser, 'Top Level Pattern') <|
    choice(
        ellipsisPattern,
        sinkPattern,
        arrayPattern,
        objectPattern,
        asPattern,
        identifierPattern);

// Arguments Pattern
////////////////////////////////////////
var argumentElements = eager <| sepBy(sep, topLevelPattern);

argumentList = (Parser, 'Argument List') <|
    node(
        argumentElements,
        \loc, elements -> ast_pattern.ArgumentsPattern.create(loc, null, elements));

argumentsPattern = (Parser, 'Arguments Pattern') <|
    either(
        attempt <| nodea(
            enumeration(
                optional(null, identifierPattern),
                between(punctuator('('), punctuator(')'),
                    argumentElements)),
            ast_pattern.ArgumentsPattern.create),
        argumentList);

// Pattern
////////////////////////////////////////
pattern = (Parser, 'Pattern') <|
    choice(
        importPattern,
        topLevelPattern);

}