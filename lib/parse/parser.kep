/**
 * @fileOverview
 */
package (
    parserStream,
    parseInput,
    parseStream)
with
    import 'parse/parse' parse,
    import 'nu/stream' {first, filter, isEmpty, rest, 'from': streamFrom},
    import 'ecma/position' {SourceLocation, SourcePosition},
    import 'ecma/parse/parser' parser,
    import 'khepri/parse/program_parser' {program}
in {
    
/* Streams
 ******************************************************************************/
/**
 * Maps a lex stream to a parse stream.
 * 
 * @param s Stream of tokens.
 * 
 * @return Stream suitable for parsing.
 */
parserStream = let 
    langElementFilter = \x -> {
        switch (x.type) {
        case 'Whitespace':
        case 'LineTerminator':
        case 'Comment':
            return false;
        default:
            return true;
        }
    }
in
    \s -> filter(langElementFilter, s);

/* State
 ******************************************************************************/
var ParserState = function(stream, pos, prevEnd) {
    parse.ParserState.call(this, stream, pos);
    this._prevEnd = prevEnd;
};
ParserState.prototype = new parse.ParserState;

ParserState.prototype.next = \tok -> {
    if (!this._next) {
        var r = rest(this.input);
        var end = (isEmpty(r) ? tok.loc.end : first(r).loc.start);
        var s = new ParserState(r, this.position.increment(tok, end), this.loc.end);
        this._next = \_, m, cok -> cok(tok, s, m);
    }
    return this._next;
};

Object.defineProperty(ParserState.prototype, 'loc', {
    'get': \() ->
        (isEmpty(this.input) ?
            new SourceLocation(this._prevEnd, this._prevEnd) :
            first(this.input).loc)
});

/* Running
 ******************************************************************************/
/**
 * Parses a lex stream into an AST.
 * 
 * May throw any parse errors.
 * 
 * @param s Stream of tokens.
 * 
 * @return AST.
 */
parseStream = \s ->
    parse.runState(
        program,
        new ParserState(
            parserStream(s),
            new parser.ParserPosition(
                parse.Position.initial,
                SourcePosition.initial),
            SourcePosition.initial));

/**
 * Parses a lex array into an AST.
 * 
 * May throw any parse errors.
 * 
 * @param input Array like object of tokens.
 * 
 * @return AST.
 */
parseInput = \input ->
    parseStream(streamFrom(input));

}