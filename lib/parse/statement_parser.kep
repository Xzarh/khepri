/**
 * @fileOverview Parser for ECMAScript 5.1 statements.
 */
package (
    blockStatement,
    staticStatement,
    variableStatement,
    emptyStatement,
    expressionStatement,
    ifStatement,
    withStatement,
    iterationStatement,
    continueStatement,
    breakStatement,
    returnStatement,
    switchStatement,
    throwStatement,
    tryStatement,
    debuggerStatement,
    statement)
with
    import 'parse/parse' parse {
        always,
        attempt,
        binds,
        choice,
        eager,
        either,
        enumeration,
        expected,
        many,
        memo,
        next,
        optional,
        Parser},
    import 'parse/lang' {between, sepBy1, then},
    import 'ecma/parse/token_parser' {keyword, punctuator},
    import 'ecma/parse/common' {node, nodea},
    import 'khepri_ast/clause' ast_clause,
    import 'khepri_ast/declaration' ast_declaration,
    import 'khepri_ast/statement' ast_statement,
    import 'khepri/parse/expression_parser' {assignmentExpression, expression},
    import 'khepri/parse/pattern_parser' {importPattern, pattern},
    import 'khepri/parse/value_parser' {identifier}
in {

/* Forward declarations
 ******************************************************************************/
statement = \... -> statement.apply(undefined, arguments);

/* Statement Parsers
 ******************************************************************************/
var logicalSemiColon = punctuator(';');

var statementList = eager(many(statement));

var topLevelExpression = either(
    attempt(assignmentExpression),
    expression);

// Block
////////////////////////////////////////
/**
 * 
 */
blockStatement = Parser('Block Statement',
    node(
        between(punctuator('{'), punctuator('}'), 
            statementList),
        ast_statement.BlockStatement.create));

// Static Statement
////////////////////////////////////////
var staticDeclaration = node(
    identifier,
    ast_declaration.StaticDeclarator.create);

var staticDeclarationList = eager(
    sepBy1(punctuator(','),
        staticDeclaration));

/**
 * Parser for a static statement that declares one or more global variables.
 */
staticStatement = Parser('Static Statement',
     node(
        between(keyword('static'), logicalSemiColon,
            staticDeclarationList),
        ast_declaration.StaticDeclaration.create));

// Variable Statement
////////////////////////////////////////
var initialiser = next(
    punctuator('='),
    topLevelExpression);

var variableDeclaration = nodea(
    enumeration(
        identifier,
        optional(null, initialiser)),
    ast_declaration.VariableDeclarator.create);

var variableDeclarationList = eager(sepBy1(punctuator(','),
    variableDeclaration));

/**
 * Parser for a variable statement which declares one or more variables with
 * optional initializer values.
 */
variableStatement = Parser('Variable Statement', 
    node(
        between(keyword('var'), logicalSemiColon,
            variableDeclarationList),
        ast_declaration.VariableDeclaration.create));


// Empty Statement
////////////////////////////////////////
/**
 * 
 */
emptyStatement = Parser('Empty Statement',
    node(
        punctuator(';'),
        ast_statement.EmptyStatement.create));

// Expression
////////////////////////////////////////
/**
 */
expressionStatement = Parser('Expression Statement',
    node(
        then(
            topLevelExpression,
            logicalSemiColon),
        ast_statement.ExpressionStatement.create));

// If
////////////////////////////////////////
/**
 * 
 */
ifStatement = Parser('If Statement',
    nodea(
        next(
            keyword('if'),
            enumeration(
                between(punctuator('('), punctuator(')'),
                    topLevelExpression),
                statement,
                optional(null, next(keyword('else'),
                    statement)))),
        ast_statement.IfStatement.create));

// With
////////////////////////////////////////
var withIdentifier = expected("Any pattern", pattern);

/**
 */
var withBinding = parse.Parser('With Binding',
    either(
        importPattern,
        nodea(
            enumeration(
                then(
                    withIdentifier,
                    punctuator('=')),
                expression),
            ast_declaration.Binding.create)));

/**
 * 
 */
withStatement = Parser('With Statement',
    nodea(
        next(
            keyword('with'),
            enumeration(
                eager(sepBy1(punctuator(','),
                    withBinding)),
                next(
                    keyword('in'),
                    blockStatement))),
        ast_statement.WithStatement.create));

// Iteration
////////////////////////////////////////
/**
 * 
 */
var whileStatement = Parser('While Statement',
    nodea(
        next(
            keyword('while'),
            enumeration(
                between(punctuator('('), punctuator(')'),
                    topLevelExpression),
                statement)),
        ast_statement.WhileStatement.create));

/**
 * 
 */
var doWhileStatement = Parser('Do While Statement',
    nodea(
        next(
            keyword('do'),
            enumeration(
                then(
                    statement,
                    keyword('while')),
                between(punctuator('('), punctuator(')'),
                    topLevelExpression),
                punctuator(';'))),
        ast_statement.DoWhileStatement.create));

var forInitExpression =  optional(null, 
    either(
        node(
            next(
                keyword('var'),
                memo(variableDeclarationList)),
            ast_declaration.VariableDeclaration.create),
        topLevelExpression));

var forTestExpression = optional(null, topLevelExpression);

var forUpdateExpression = optional(null,
    either(
        attempt(assignmentExpression),
        topLevelExpression));

/**
 * 
 */
var forStatement = Parser('For Statement',
    nodea(
        next(
            keyword('for'),
            enumeration(
                next(
                    punctuator('('),
                    forInitExpression),
                next(
                    punctuator(';'),
                    forTestExpression),
                next(
                    punctuator(';'),
                    forUpdateExpression),
                next(
                    punctuator(')'),
                    statement))),
        ast_statement.ForStatement.create));

iterationStatement = Parser('Iteration Statement',
    choice(
        doWhileStatement,
        whileStatement,
        forStatement));

// Continue
////////////////////////////////////////
/**
 */
continueStatement = Parser('Continue Statement',
    node(
        next(
            keyword('continue'),
            logicalSemiColon),
        ast_statement.ContinueStatement.create));

// Break
////////////////////////////////////////
/**
 */
breakStatement = Parser('Break Statement',
    node(
        next(
            keyword('break'),
            logicalSemiColon),
        ast_statement.BreakStatement.create));

// Return
////////////////////////////////////////
/**
 */
returnStatement = Parser('Return Statement',
    node(
        between(keyword('return'), logicalSemiColon,
            optional(null, topLevelExpression)),
        ast_statement.ReturnStatement.create));

// Switch
////////////////////////////////////////
var caseClause = nodea(
    next(
        keyword('case'),
        enumeration(
            then(
                topLevelExpression,
                punctuator(':')),
            statementList)),
    ast_clause.SwitchCase.create);

var defaultClause = node(
    next(
        keyword('default'),
        next(
            punctuator(':'),
            statementList)),
    \loc, consequent -> ast_clause.SwitchCase.create(loc, null, consequent));

var caseClauses = eager(many(caseClause));

var caseBlock = between(punctuator('{'), punctuator('}'),
    binds(
        enumeration(
            optional([], caseClauses),
            optional(null, defaultClause)),
        \first, defaultClause ->
            always(defaultClause ?
                first.concat([defaultClause]) :
                first)));

/**
 * 
 */
switchStatement = Parser('Switch Statement',
    nodea(
        next(
            keyword('switch'),
            enumeration(
                between(punctuator('('), punctuator(')'),
                    topLevelExpression),
                caseBlock)),
        ast_statement.SwitchStatement.create));

// Throw
////////////////////////////////////////
/**
 * 
 */
throwStatement = Parser('Throw Statement',
    node(
        between(keyword('throw'), logicalSemiColon,
            topLevelExpression),
        ast_statement.ThrowStatement.create));

// Try
////////////////////////////////////////
var catchBlock = nodea(
    next(
        keyword('catch'),
        enumeration(
            between(punctuator('('), punctuator(')'),
                identifier),
            blockStatement)),
    ast_clause.CatchClause.create);

var finallyBlock = next(
    keyword('finally'),
    blockStatement);

/**
 * 
 */
tryStatement = Parser('Try Statement',
    nodea(
        next(
            keyword('try'),
            enumeration(
                blockStatement,
                optional(null, catchBlock),
                optional(null, finallyBlock))),
        ast_statement.TryStatement.create));

// Debugger
////////////////////////////////////////
/**
 * Parser for a debugger statement.
 */
debuggerStatement = Parser('Debugger Statement',
    node(
        next(
            keyword('debugger'),
            punctuator(';')),
        ast_statement.DebuggerStatement.create));

// statement
////////////////////////////////////////
/**
 * 
 */
statement = Parser('Statement',
    expected("statement", choice(
        blockStatement,
        staticStatement,
        variableStatement,
        emptyStatement,
        ifStatement,
        withStatement,
        iterationStatement,
        continueStatement,
        breakStatement,
        returnStatement,
        switchStatement,
        throwStatement,
        tryStatement,
        debuggerStatement,
        expressionStatement)));

}