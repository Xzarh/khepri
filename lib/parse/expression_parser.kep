/**
 * @fileOverview Khepri expression parsers.
 */
static define;
define(['require',
        'parse/parse',
        'parse/lang',
        'nu/stream', 
        'ecma/position',
        'ecma/parse/common',
        'ecma/parse/token_parser',
        'khepri_ast/declaration',
        'khepri_ast/expression',
        'khepri_ast/statement',
        'khepri_ast/pattern',
        'khepri/parse/program_parser',
        'khepri/parse/value_parser',
        'khepri/parse/pattern_parser'],
function(require,
        parse,
        parse_lang,
        stream,
        position,
        ecma_parse,
        token,
        ast_declaration,
        ast_expression,
        ast_statement,
        ast_pattern,
        program,
        value,
        pattern){
"use strict";

/* Circular Declarations 
 ******************************************************************************/
var sourceElements = function() {
    return require('khepri/parse/program_parser').sourceElements.apply(undefined, arguments);
};

/* Forward Declarations
 ******************************************************************************/
var expression = function() { return expression.apply(undefined, arguments); };

var conditionalExpression = function() { return conditionalExpression.apply(undefined, arguments); };

var newExpression = function() { return newExpression.apply(undefined, arguments); };

/* Parsers
 ******************************************************************************/
/**
 * Parser for the body of a function.
 */
var functionBody = ecma_parse.node(
    sourceElements,
    ast_statement.BlockStatement.create);

// Array Literal
////////////////////////////////////////
/**
 * Parser for an element in an array literal.
 */
var arrayElement = parse.Parser('Array Element',
    parse.either(
        expression,
        parse.next(
            parse.lookahead(token.punctuator(',')),
            parse.always(null))));

/**
 * Parser for the elements of an array literal.
 */
var arrayElements = parse.Parser('Array Elements',
    parse.eager(parse_lang.sepBy(token.punctuator(','),
        parse.expected('array element', arrayElement))));

/**
 * Parser for an ECMASccript array literal.
 */
var arrayLiteral = parse.Parser('Array Literal',
    ecma_parse.node(
        parse_lang.between(token.punctuator('['), token.punctuator(']'),
            arrayElements),
        ast_expression.ArrayExpression.create));

// Object Literal
////////////////////////////////////////
/**
 * Parser for an object property name.
 */
var propertyName = parse.Parser('Property Name',
    value.stringLiteral);

/**
 * Parser for the argument list of a object set initializer property.
 */
var propertySetParameterList = parse.bind(value.identifier, \x ->
    parse.always([x]));

/**
 * Parser for the standard key to value property initializer.
 */
var propertyValueInitializer = parse.Parser('Property Value Initializer',
    ecma_parse.nodea(
        parse.enumeration(
            propertyName,
            token.punctuator(':'),
            expression),
        \(loc, name, _, value) -> ({
            'loc': loc,
            'key': name,
            'kind': 'init',
            'value': value
        })));

/**
 * Parser for a getter for a property.
 */
var propertyGetInitializer = parse.Parser('Property Get Initializer',
    ecma_parse.nodea(
        parse.next(
            token.keyword('get'),
            parse.enumeration(
                propertyName,
                token.punctuator('('),
                token.punctuator(')'),
                parse_lang.between(token.punctuator('{'), token.punctuator('}'),
                    functionBody))),
        \(loc, name, _0, _1, body) -> ({
            'loc': loc,
            'key': name,
            'kind': 'get',
            'value': ast_expression.FunctionExpression.create(loc, null, [], body)
        })));

/**
 * Parser for a setter for a property.
 */
var propertySetInitializer = parse.Parser('Property Set Initializer',
    ecma_parse.nodea(
        parse.next(
            token.keyword('set'),
            parse.enumeration(
                propertyName,
                parse_lang.between(token.punctuator('('), token.punctuator(')'),
                    propertySetParameterList),
                parse_lang.between(token.punctuator('{'), token.punctuator('}'),
                    functionBody))),
        \(loc, name, parameters, body) -> ({
                'loc': loc,
                'key': name,
                'kind': 'set',
                'value': ast_expression.FunctionExpression.create(loc, null, parameters, body)
            })));

/**
 * Parser for any property initializer.
 */
var propertyInitializer = parse.Parser('Property Initializer',
    parse.choice(
        parse.attempt(propertyValueInitializer),
        propertyGetInitializer,
        propertySetInitializer));

/**
 * Parser for a set or more properties in an object literal.
 */
var objectProperties = parse.Parser('Object Properties',
    parse.eager(
        parse_lang.sepBy(token.punctuator(','),
            propertyInitializer)));

/**
 * Parser for an ECMAScript object literal.
 */
var objectLiteral = parse.Parser('Object Literal',
    ecma_parse.node(
        parse_lang.between(token.punctuator('{'), token.punctuator('}'),
            objectProperties),
        ast_expression.ObjectExpression.create));

// Function Expression
////////////////////////////////////////
var parameter = parse.expected("Any pattern", pattern.pattern);

/**
 * Parser for a function's parameters.
 */
var formalParameterList = ecma_parse.node(
    parse.eager(parse_lang.sepBy(token.punctuator(','),
        parameter)),
    ast_pattern.ParameterList.create);

var ecmaFunctionExpression = ecma_parse.nodea(
    parse.next(
        token.keyword('function'),
        parse.enumeration(
            parse.optional(null, value.identifier),
            parse_lang.between(token.punctuator('('), token.punctuator(')'), 
                formalParameterList),
            parse_lang.between(token.punctuator('{'), token.punctuator('}'),
                functionBody))),
    ast_expression.FunctionExpression.create);

var lambdaFormalParameterList = parse.either(
    parse_lang.between(token.punctuator('('), token.punctuator(')'), 
        formalParameterList),
    formalParameterList);

var lambdaBody = parse.either(
    parse_lang.between(token.punctuator('{'), token.punctuator('}'),
        functionBody),
    ecma_parse.node(
        expression,
        \(loc, x) ->
            new ast_statement.BlockStatement(loc, [new ast_statement.ReturnStatement(loc, x)])));

var lambdaFunctionExpression = ecma_parse.nodea(
    parse.next(
        token.punctuator('\\'),
        parse.enumeration(
            lambdaFormalParameterList,
            token.punctuator('->'),
            lambdaBody)),
    \(loc, parameters, _, body) ->
        ast_expression.FunctionExpression.create(loc, null, parameters, body));

/**
 * Parser for an function expression.
 * 
 * May be named or anon.
 */
var functionExpression = parse.Parser('Function Expression',
    parse.either(
        ecmaFunctionExpression,
        lambdaFunctionExpression));

// This Expression
////////////////////////////////////////
var thisExpression = ecma_parse.node(
    token.keyword('this'),
    ast_expression.ThisExpression.create);

// Let Expression
////////////////////////////////////////
var letIdentifier = parse.expected("Any pattern", pattern.pattern);

/**
 * Parser for a let binding.
 */
var letBinding =  parse.Parser('Let Binding',
    ecma_parse.nodea(
        parse.enumeration(
            parse_lang.then(
                letIdentifier,
                token.punctuator('=')),
            conditionalExpression),
       ast_declaration.LetBinding.create));

/**
 * Parser for a let expression.
 */
var letExpression = parse.Parser('Let Expression',
    ecma_parse.nodea(
        parse.next(
            token.keyword('let'),
            parse.enumeration(
                parse.eager(parse_lang.sepBy1(token.punctuator(','),
                    letBinding)),
                parse.next(
                    token.keyword('in'),
                    conditionalExpression))),
        ast_expression.LetExpression.create));

// Primary Expression
////////////////////////////////////////
var primaryExpression = parse.Parser('Primary Expression',
    parse.choice(
        thisExpression,
        letExpression,
        value.identifier,
        parse_lang.between(token.punctuator('('), token.punctuator(')'),
            expression),
        value.literal,
        arrayLiteral,
        objectLiteral,
        functionExpression));

// Calling
////////////////////////////////////////
/**
 * Parser for a list of arguments.
 */
var argumentList = parse.Parser('Argument List',
    parse.eager(parse_lang.sepBy(token.punctuator(','),
        parse.expected("expression", expression))));

/**
 * Parser for a argument list part of a call expression.
 */
var args = parse.Parser('Arguments',
    ecma_parse.node(
        parse_lang.between(token.punctuator('('), token.punctuator(')'),
            argumentList),
        \(loc, args) -> {
            args.loc = loc;
            args.argument = true;
            return args;
        }));

// Accessors
////////////////////////////////////////
/**
 * Parser for a dot accessor in a member expression.
 */
var dotAccessor = parse.Parser('Dot Accessor',
    ecma_parse.node(
        parse.next(
            token.punctuator('.'),
            value.identifier),
        \(loc, x) -> [{
            'loc': loc,
            'property': x,
            'computed': false
        }]));

/**
 * Parser for a bracket accessor in a member expression.
 */
var bracketAccessor = parse.Parser('Bracket Accessor',
    parse.bind(
        parse_lang.between(token.punctuator('['), token.punctuator(']'),
            parse.eager(parse_lang.sepBy1(token.punctuator(','),
                expression))),
        \accessor -> parse.always(accessor.map(\x -> ({
            'loc': x.loc,
            'property': x,
            'computed': true
        })))));

/**
 * Parser for an accessor in a member expression.
 */
var accessor = parse.Parser('Accessor',
    parse.either(
        dotAccessor,
        bracketAccessor));

var accessorReducer = \p, c -> 
    ast_expression.MemberExpression.create(
        position.SourceLocation.merge(p.loc, c.loc),
        p,
        c.property,
        c.computed);

/**
 * 
 */
var memberExpression = let
    reducer = \(p, c) -> c.reduce(accessorReducer, p)
in
        parse.Parser('Member Expression',
            parse.binds(
                parse.enumeration(
                    parse.either(
                        newExpression,
                        primaryExpression),
                    parse.many(accessor)),
                \(expression, props) ->
                     parse.always(stream.foldl(reducer, expression, props))));

// New Expression
////////////////////////////////////////
/**
 * Parser for a new expression
 */
newExpression = parse.Parser('New Expression',
    ecma_parse.nodea(
        parse.next(
            token.keyword('new'),
            parse.enumeration(
                parse.expected("member expression", memberExpression),
                parse.optional([], args))),
        ast_expression.NewExpression.create));

// Left Hand Side Expression
////////////////////////////////////////
/**
 * Parser for a left hand side expression.
 */
var leftHandSideExpression = let
reducer = \p, c ->
    (c && c.hasOwnProperty('argument') ?
         ast_expression.CallExpression.create(position.SourceLocation.merge(p.loc, c.loc), p, c) :
         c.reduce(accessorReducer, p))
in
    parse.Parser('Left Hand Side Expression',
        parse.binds(
            parse.enumeration(
                parse.memo(memberExpression),
                parse.many(parse.either(
                    args,
                    accessor))),
            \(member, accessors) ->
                parse.always(stream.foldl(reducer, member, accessors))));

// Left Hand Side Expression
////////////////////////////////////////
/**
 * Parser for a left hand side expression.
 */
var leftHandReferenceExpression =
    let reducer = \(p, c) -> c.reduce(accessorReducer, p) in
        parse.Parser('Left Hand Reference Expression',
            parse.binds(
                parse.enumeration(
                    parse.choice(
                        thisExpression,
                        value.identifier),
                    parse.many(accessor)),
                \(expression, props) ->
                     parse.always(stream.foldl(reducer, expression, props))));

// Unary Expression
////////////////////////////////////////
var unaryOperator = parse.Parser('Unary Operator',
    parse.choice(
        token.keyword('delete'),
        token.keyword('void'),
        token.keyword('typeof'),
        token.punctuator('+'),
        token.punctuator('-'),
        token.punctuator('~'),
        token.punctuator('!')));

/**
 * 
 */
var unaryExpression = let
reducer = \argument, op -> 
    ast_expression.UnaryExpression.create(
        position.SourceLocation.merge(op.loc, argument.loc),
        op.value,
        argument)
in
    parse.Parser('Unary Expression',
        parse.binds(
            parse.enumeration(
                parse.many(unaryOperator),
                parse.expected('left hand side expression', leftHandSideExpression)),
            \(ops, expression) ->
                parse.always(stream.foldr(reducer, expression, ops))));

// Binary Expressions
////////////////////////////////////////
var multiplicativeOperator = parse.choice(
    token.punctuator('*'),
    token.punctuator('/'),
    token.punctuator('%'));

var additiveOperator = parse.either(
    token.punctuator('+'),
    token.punctuator('-'));

var shiftOperator = parse.choice(
    token.punctuator('<<'),
    token.punctuator('>>'),
    token.punctuator('>>>'));

var relationalOperator = parse.choice(
    token.punctuator('<'),
    token.punctuator('>'),
    token.punctuator('<='),
    token.punctuator('>='),
    token.keyword('instanceof'));

var equalityOperator = parse.choice(
    token.punctuator('=='),
    token.punctuator('!='),
    token.punctuator('==='),
    token.punctuator('!=='));

var bitwiseANDOperator = token.punctuator('&');

var bitwiseXOROperator = token.punctuator('^');

var bitwiseOROperator = token.punctuator('|');

var logicalANDOperator = token.punctuator('&&');

var logicalOROperator = token.punctuator('||');

var precedenceTable = [
    {
        'sep': multiplicativeOperator,
        'precedence': 1,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': additiveOperator,
        'precedence': 2,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': shiftOperator,
        'precedence': 3,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': equalityOperator,
        'precedence': 5,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': bitwiseANDOperator,
        'precedence': 6,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': bitwiseXOROperator,
        'precedence': 7,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': bitwiseOROperator,
        'precedence': 8,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': logicalOROperator,
        'precedence': 9,
        'node': ast_expression.LogicalExpression
    },
    {
        'sep': logicalANDOperator,
        'precedence': 10,
        'node': ast_expression.LogicalExpression
    },
    {
        'sep': relationalOperator,
        'precedence': 4,
        'node': ast_expression.BinaryExpression
    }
];

var binaryExpression = parse.Parser('Binary Expression',
    ecma_parse.precedence(unaryExpression, precedenceTable));

// Conditional Expression
////////////////////////////////////////
/**
 * 
 */
conditionalExpression = let
    conditionalBody = parse.next(
        token.punctuator('?'),
        parse.enumeration(
            parse.expected("expression", expression),
            token.punctuator(':'),
            parse.expected("expression", expression)))
in
    parse.bind(binaryExpression, \bin -> 
        parse.optional(bin,
            ecma_parse.nodea(
                conditionalBody,
                \loc, consequent, _1, alternate ->
                    ast_expression.ConditionalExpression.create(loc, bin, consequent, alternate))));

// Assignment Statement
////////////////////////////////////////
var assignmentOperator = parse.Parser('Assignment Operator',
    parse.choice(
        token.punctuator('='),
        token.punctuator('*='),
        token.punctuator('*='),
        token.punctuator('/='),
        token.punctuator('%='),
        token.punctuator('+='),
        token.punctuator('-='),
        token.punctuator('<<='),
        token.punctuator('>>='),
        token.punctuator('>>>='),
        token.punctuator('&='),
        token.punctuator('^='),
        token.punctuator('|=')));

/**
 * 
 */
var assignmentExpression = parse.Parser('Assignment Expression',
    ecma_parse.nodea(
        parse.enumeration(
            leftHandReferenceExpression,
            assignmentOperator,
            parse.expected('expression', expression)),
        \loc, left, op, right ->
            new ast_expression.AssignmentExpression(loc, op.value, left, right)));

// Expression
////////////////////////////////////////
expression = conditionalExpression;

/* Export
 ******************************************************************************/
return {
// Array Literal
    'arrayElement': arrayElement,
    'arrayElements': arrayElements,
    'arrayLiteral': arrayLiteral,
    
// Object Literal
    'propertyName': propertyName,
    'propertySetParameterList': propertySetParameterList,
    'propertyValueInitializer': propertyValueInitializer,
    'propertyGetInitializer': propertyGetInitializer,
    'propertySetInitializer': propertySetInitializer,
    'propertyInitializer': propertyInitializer,
    'objectProperties': objectProperties,
    'objectLiteral': objectLiteral,
    
// Primary Expression
    'primaryExpression': primaryExpression,
    
// This Expression
    'thisExpression': thisExpression,
    
// Call Expression
    'args': args,
    'argumentList': argumentList,
    
// Member Expression
    'dotAccessor': dotAccessor,
    'bracketAccessor': bracketAccessor,
    'accessor': accessor,
    'memberExpression': memberExpression,
    
// New Expression
    'newExpression': newExpression,
    
// Left hand side expression
    'leftHandSideExpression': leftHandSideExpression,
    'leftHandReferenceExpression': leftHandReferenceExpression,
// Unary Expression
    'unaryOperator': unaryOperator,
    'unaryExpression': unaryExpression,
    
// Binary Expression
    'binaryExpression': binaryExpression,
    
// Conditional Expression
    'conditionalExpression': conditionalExpression,

// Let Expression
    'letExpression': letExpression,

// Assignment
    'assignmentExpression': assignmentExpression,
    
// Expression
    'expression': expression
};

});