/**
 * @fileOverview Khepri expression parsers.
 */
package (
// Array Literal
    arrayElement,
    arrayElements,
    arrayLiteral,
    
// Object Literal
    propertyName,
    propertySetParameterList,
    propertyValueInitializer,
    propertyGetInitializer,
    propertySetInitializer,
    propertyInitializer,
    objectProperties,
    objectLiteral,
    
// Primary Expression
    primaryExpression,
    
// This Expression
    thisExpression,
    
// Call Expression
    args,
    argumentList,
    
// Member Expression
    dotAccessor,
    bracketAccessor,
    accessor,
    memberExpression,
    
// New Expression
    newExpression,
    
// Left hand side expression
    leftHandSideExpression,
    leftHandReferenceExpression,
    
// Unary Expression
    unaryOperator,
    unaryExpression,
    
// Binary Expression
    binaryExpression,
    
// Conditional Expression
    conditionalExpression,

// Let Expression
    letExpression,

// Assignment
    assignmentOperator,
    assignmentExpression,

// Compose
    composeExpression,
    
// Expression
    expression)
with
    import 'parse/parse' {
        always,
        attempt,
        bind,
        binds,
        choice,
        eager,
        either,
        enumeration,
        expected,
        lookahead,
        many,
        memo,
        next,
        optional,
        Parser},
    import'parse/lang' {
        between,
        sepBy,
        sepBy1,
        then},
    import 'nu/stream' {foldl, foldr},
    import 'khepri_ast/declaration' ast_declaration,
    import 'khepri_ast/expression' ast_expression,
    import 'khepri_ast/statement' ast_statement,
    import 'khepri_ast/pattern' ast_pattern,
    import 'khepri/position' {SourceLocation},
    import 'khepri/parse/common' {node, nodea, precedence},
    import 'khepri/parse/token_parser' {keyword, punctuator},
    import 'khepri/parse/program_parser' _,
    import 'khepri/parse/value_parser' {identifier, literal, stringLiteral},
    import 'khepri/parse/pattern_parser' pattern
in {

/* Circular Declarations 
 ******************************************************************************/
var sourceElements = \... -> {
    with
        import 'khepri/parse/program_parser' {sourceElements}
    in {
        return sourceElements.apply(undefined, arguments);
    }
};

/* Forward Declarations
 ******************************************************************************/
expression = \... -> expression.apply(undefined, arguments);

conditionalExpression = \... -> conditionalExpression.apply(undefined, arguments);

newExpression = \... -> newExpression.apply(undefined, arguments);

/* Parsers
 ******************************************************************************/
/**
 * Parser for the body of a function.
 */
var functionBody = node(
    sourceElements,
    ast_statement.BlockStatement.create);

// Array Literal
////////////////////////////////////////
/**
 * Parser for an element in an array literal.
 */
arrayElement = Parser('Array Element',
    expression);

/**
 * Parser for the elements of an array literal.
 */
arrayElements = Parser('Array Elements',
    eager(sepBy(punctuator(','),
        expected('array element', arrayElement))));

/**
 * Parser for an ECMASccript array literal.
 */
arrayLiteral = Parser('Array Literal',
    node(
        between(punctuator('['), punctuator(']'),
            arrayElements),
        ast_expression.ArrayExpression.create));

// Object Literal
////////////////////////////////////////
/**
 * Parser for an object property name.
 */
propertyName = Parser('Property Name',
    stringLiteral);

/**
 * Parser for the argument list of a object set initializer property.
 */
propertySetParameterList = bind(identifier, \x ->
    always([x]));

/**
 * Parser for the standard key to value property initializer.
 */
propertyValueInitializer = Parser('Property Value Initializer',
    nodea(
        enumeration(
            propertyName,
            punctuator(':'),
            expression),
        \loc, name, _, value -> ({
            'loc': loc,
            'key': name,
            'kind': 'init',
            'value': value
        })));

/**
 * Parser for a getter for a property.
 */
propertyGetInitializer = Parser('Property Get Initializer',
    nodea(
        next(
            keyword('get'),
            enumeration(
                propertyName,
                punctuator('('),
                punctuator(')'),
                between(punctuator('{'), punctuator('}'),
                    functionBody))),
        \loc, name, _0, _1, body -> ({
            'loc': loc,
            'key': name,
            'kind': 'get',
            'value': ast_expression.FunctionExpression.create(loc, null, [], body)
        })));

/**
 * Parser for a setter for a property.
 */
propertySetInitializer = Parser('Property Set Initializer',
    nodea(
        next(
            keyword('set'),
            enumeration(
                propertyName,
                between(punctuator('('), punctuator(')'),
                    propertySetParameterList),
                between(punctuator('{'), punctuator('}'),
                    functionBody))),
        \loc, name, parameters, body -> ({
                'loc': loc,
                'key': name,
                'kind': 'set',
                'value': ast_expression.FunctionExpression.create(loc, null, parameters, body)
            })));

/**
 * Parser for any property initializer.
 */
propertyInitializer = Parser('Property Initializer',
    choice(
        attempt(propertyValueInitializer),
        propertyGetInitializer,
        propertySetInitializer));

/**
 * Parser for a set or more properties in an object literal.
 */
objectProperties = Parser('Object Properties',
    eager(
        sepBy(punctuator(','),
            propertyInitializer)));

/**
 * Parser for an ECMAScript object literal.
 */
objectLiteral = Parser('Object Literal',
    node(
        between(punctuator('{'), punctuator('}'),
            objectProperties),
        ast_expression.ObjectExpression.create));

// Function Expression
////////////////////////////////////////
/**
 * Parser for a function's parameters.
 */
var formalParameterList = pattern.argumentsPattern;

var ecmaFunctionExpression = nodea(
    next(
        keyword('function'),
        enumeration(
            optional(null, identifier),
            between(punctuator('('), punctuator(')'), 
                formalParameterList),
            between(punctuator('{'), punctuator('}'),
                functionBody))),
    ast_expression.FunctionExpression.create);

var lambdaFormalParameterList = pattern.argumentsPattern;

var lambdaBody = either(
    between(punctuator('{'), punctuator('}'),
        functionBody),
    node(
        conditionalExpression,
        \loc, x ->
            ast_statement.BlockStatement.create(loc, [ast_statement.ReturnStatement.create(null, x)])));

var lambdaFunctionExpression = nodea(
    next(
        punctuator('\\'),
        enumeration(
            lambdaFormalParameterList,
            next(
                punctuator('->'),
                lambdaBody))),
    \loc, parameters, body ->
        ast_expression.FunctionExpression.create(loc, null, parameters, body));

/**
 * Parser for an function expression.
 * 
 * May be named or anon.
 */
var functionExpression = Parser('Function Expression',
    either(
        ecmaFunctionExpression,
        lambdaFunctionExpression));

// This Expression
////////////////////////////////////////
thisExpression = node(
    keyword('this'),
    ast_expression.ThisExpression.create);

// Let Expression
////////////////////////////////////////
var letIdentifier = expected("Any pattern", pattern.pattern);

/**
 * Parser for a let binding.
 */
var letBinding =  Parser('Let Binding',
    nodea(
        enumeration(
            then(
                letIdentifier,
                punctuator('=')),
            expected('expression', expression)),
       ast_declaration.Binding.create));

/**
 * Parser for a let expression.
 */
letExpression = Parser('Let Expression', let
    letBindings = expected('let bindings',
        sepBy1(punctuator(','),
            letBinding)),
    
    letBody = expected('expression', expression)
in
    nodea(
        next(
            keyword('let'),
            enumeration(
                eager(letBindings),
                next(
                    keyword('in'),
                    letBody))),
        ast_expression.LetExpression.create));

// Primary Expression
////////////////////////////////////////
primaryExpression = Parser('Primary Expression',
    choice(
        thisExpression,
        letExpression,
        identifier,
        between(punctuator('('), punctuator(')'),
            expression),
        literal,
        arrayLiteral,
        objectLiteral,
        functionExpression));

// Calling
////////////////////////////////////////
/**
 * Parser for a list of arguments.
 */
argumentList = Parser('Argument List',
    eager(sepBy(punctuator(','),
        expected("expression", expression))));

/**
 * Parser for a argument list part of a call expression.
 */
args = Parser('Arguments',
    node(
        between(punctuator('('), punctuator(')'),
            argumentList),
        \loc, args -> {
            args.loc = loc;
            args.argument = true;
            return args;
        }));

// Accessors
////////////////////////////////////////
/**
 * Parser for a dot accessor in a member expression.
 */
dotAccessor = Parser('Dot Accessor',
    node(
        next(
            punctuator('.'),
            identifier),
        \loc, x -> [{
            'loc': loc,
            'property': x,
            'computed': false
        }]));

/**
 * Parser for a bracket accessor in a member expression.
 */
bracketAccessor = Parser('Bracket Accessor',
    bind(
        between(punctuator('['), punctuator(']'),
            eager(sepBy1(punctuator(','),
                expression))),
        \accessor -> always(accessor.map(\x -> ({
            'loc': x.loc,
            'property': x,
            'computed': true
        })))));

/**
 * Parser for an accessor in a member expression.
 */
accessor = Parser('Accessor',
    either(
        dotAccessor,
        bracketAccessor));

var accessorReducer = \p, c -> 
    ast_expression.MemberExpression.create(
        SourceLocation.merge(p.loc, c.loc),
        p,
        c.property,
        c.computed);

/**
 * 
 */
memberExpression = let
    reducer = \p, c -> c.reduce(accessorReducer, p)
in
    Parser('Member Expression',
        binds(
            enumeration(
                either(
                    newExpression,
                    primaryExpression),
                many(accessor)),
            \expression, props ->
                 always(foldl(reducer, expression, props))));

// New Expression
////////////////////////////////////////
/**
 * Parser for a new expression
 */
newExpression = Parser('New Expression',
    nodea(
        next(
            keyword('new'),
            enumeration(
                expected("member expression", memberExpression),
                optional([], args))),
        ast_expression.NewExpression.create));

// Left Hand Side Expression
////////////////////////////////////////
/**
 * Parser for a left hand side expression.
 */
leftHandSideExpression = let
    reducer = \p, c ->
        (c && c.hasOwnProperty('argument') ?
             ast_expression.CallExpression.create(SourceLocation.merge(p.loc, c.loc), p, c) :
             c.reduce(accessorReducer, p))
in
    Parser('Left Hand Side Expression',
        binds(
            enumeration(
                memo(memberExpression),
                many(either(
                    args,
                    accessor))),
            \member, accessors ->
                always(foldl(reducer, member, accessors))));

// Left Hand Side Expression
////////////////////////////////////////
/**
 * Parser for a left hand side expression.
 */
leftHandReferenceExpression = let
    reducer = \p, c -> c.reduce(accessorReducer, p)
in
    Parser('Left Hand Reference Expression',
        binds(
            enumeration(
                choice(thisExpression, identifier),
                many(accessor)),
            \expression, props ->
                 always(foldl(reducer, expression, props))));

// Unary Expression
////////////////////////////////////////
unaryOperator = Parser('Unary Operator',
    choice(
        keyword('delete', 'void', 'typeof'),
        punctuator('+', '-', '~', '!')));

/**
 * 
 */
unaryExpression = let
    reducer = \argument, op -> 
        ast_expression.UnaryExpression.create(
            SourceLocation.merge(op.loc, argument.loc),
            op.value,
            argument)
in
    Parser('Unary Expression',
        binds(
            enumeration(
                many(unaryOperator),
                expected('left hand side expression', leftHandSideExpression)),
            \ops, expression ->
                always(foldr(reducer, expression, ops))));

// Binary Expressions
////////////////////////////////////////
var multiplicativeOperator = punctuator('*', '/', '%');

var additiveOperator = punctuator('+', '-');

var shiftOperator = punctuator('<<', '>>', '>>>');

var relationalOperator = either(
    punctuator('<', '>', '<=', '>='),
    keyword('instanceof'));

var equalityOperator = punctuator('==', '!=', '===', '!==');

var bitwiseANDOperator = punctuator('&');

var bitwiseXOROperator = punctuator('^');

var bitwiseOROperator = punctuator('|');

var logicalANDOperator = punctuator('&&');

var logicalOROperator = punctuator('||');

var precedenceTable = [
    {
        'sep': multiplicativeOperator,
        'precedence': 1,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': additiveOperator,
        'precedence': 2,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': shiftOperator,
        'precedence': 3,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': relationalOperator,
        'precedence': 4,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': equalityOperator,
        'precedence': 5,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': bitwiseANDOperator,
        'precedence': 6,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': bitwiseXOROperator,
        'precedence': 7,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': bitwiseOROperator,
        'precedence': 8,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': logicalOROperator,
        'precedence': 12,
        'node': ast_expression.LogicalExpression
    },
    {
        'sep': logicalANDOperator,
        'precedence': 13,
        'node': ast_expression.LogicalExpression
    }
];

binaryExpression = Parser('Binary Expression',
    precedence(unaryExpression, precedenceTable));

// Conditional Expression
////////////////////////////////////////
/**
 * 
 */
conditionalExpression = let
    conditionalBody = next(
        punctuator('?'),
        enumeration(
            expected("expression", expression),
            next(
                punctuator(':'),
                expected("expression", expression))))
in
    bind(binaryExpression, \bin -> 
        optional(bin,
            nodea(
                conditionalBody,
                \loc, consequent, alternate ->
                    ast_expression.ConditionalExpression.create(loc, bin, consequent, alternate))));

// Compose Operator
////////////////////////////////////////
var composeOperator = punctuator('\\>');

var pipeOperator = punctuator('|>');

var composePrecedenceTable = [
    {
        'sep': composeOperator,
        'precedence': 1,
        'node': ast_expression.BinaryExpression
    },
    {
        'sep': pipeOperator,
        'precedence': 2,
        'node': ast_expression.BinaryExpression
    }
];

composeExpression = Parser('Compose Expression',
    precedence(conditionalExpression, composePrecedenceTable));

// Assignment Expression
////////////////////////////////////////
assignmentOperator = Parser('Assignment Operator',
    punctuator(
        '=',
        '*=',
        '*=',
        '/=',
        '%=',
        '+=',
        '-=',
        '<<=',
        '>>=',
        '>>>=',
        '&=',
        '^=',
        '|='));

assignmentExpression = Parser('Assignment Expression',
    nodea(
        enumeration(
            leftHandReferenceExpression,
            assignmentOperator,
            expected('expression', expression)),
        \loc, left, op, right ->
            ast_expression.AssignmentExpression.create(loc, op.value, left, right)));

// Expression
////////////////////////////////////////
expression = composeExpression;

}