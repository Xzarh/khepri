/**
 * @fileOverview Parser for ECMAScript 5.1 expression.
 */
define(['require',
        'parse/parse', 'parse/parse_eager',
        'nu/stream', 
        'ecma/parse/common',
        'ecma/position',
        'khepri/parse/program_parser', 'khepri/parse/value_parser',
        'ecma/parse/token_parser',
        'ecma/ast/node', 'ecma/ast/expression', 'ecma/ast/statement', 'ecma/ast/value'],
function(require,
        parse, parse_eager,
        stream,
        ecma_parse,
        position,
        program, value,
        token,
        node, astExpression, astStatement, astValue){
"use strict";

/* Circular Declarations
 ******************************************************************************/
var sourceElements = function() {
    return require('khepri/parse/program_parser').sourceElements.apply(undefined, arguments);
};

/* Forward Declarations
 ******************************************************************************/
var assignmentExpression = function() { return assignmentExpression.apply(undefined, arguments); };

var expression = function() { return expression.apply(undefined, arguments); };

var newExpression = function() { return newExpression.apply(undefined, arguments); };

/* Parsers
 ******************************************************************************/
/**
 * Parser for the body of a function.
 */
var functionBody = ecma_parse.node(
    sourceElements,
    (loc, body) ->
        new astStatement.BlockStatement(loc, body));

// Array Literal
////////////////////////////////////////
/**
 * Parser for an element in an array literal.
 */
var arrayElement = parse.Parser('Array Element',
    parse.either(
        assignmentExpression,
        parse.next(
            parse.lookahead(token.punctuator(',')),
            parse.always(null))));

/**
 * Parser for the elements of an array literal.
 */
var arrayElements = parse.Parser('Array Elements',
    parse.bind(
        parse.sepBy(token.punctuator(','),
            parse.expected('array element', arrayElement)),
        elements ->
            parse.always(stream.toArray(elements))));

/**
 * Parser for an ECMASccript array literal.
 */
var arrayLiteral = parse.Parser('Array Literal',
    ecma_parse.node(
        parse.between(token.punctuator('['), token.punctuator(']'),
            arrayElements),
        (loc, elements) ->
            new astExpression.ArrayExpression(loc, elements)));

// Object Literal
////////////////////////////////////////
/**
 * Parser for an object property name.
 */
var propertyName = parse.Parser('Property Name',
    value.stringLiteral);

/**
 * Parser for the argument list of a object set initializer property.
 */
var propertySetParameterList = parse.bind(value.identifier, x ->
    parse.always([x]));


/**
 * Parser for the standard key to value property initializer.
 */
var propertyValueInitializer = parse.Parser('Property Value Initializer',
    ecma_parse.nodea(
        parse.sequence(
            propertyName,
            token.punctuator(':'),
            assignmentExpression),
        (loc, name, _, value) -> ({
            'loc': loc,
            'key': name,
            'kind': 'init',
            'value': value
        })));

/**
 * Parser for a getter for a property.
 */
var propertyGetInitializer = parse.Parser('Property Get Initializer',
    ecma_parse.nodea(
        parse.next(
            token.keyword('get'),
            parse.sequence(
                propertyName,
                token.punctuator('('),
                token.punctuator(')'),
                parse.between(token.punctuator('{'), token.punctuator('}'),
                    functionBody))),
        (loc, name, _0, _1, body) -> ({
            'loc': loc,
            'key': name,
            'kind': 'get',
            'value': new astExpression.FunctionExpression(loc, null, [], body)
        })));

/**
 * Parser for a setter for a property.
 */
var propertySetInitializer = parse.Parser('Property Set Initializer',
    ecma_parse.nodea(
        parse.next(
            token.keyword('set'),
            parse.sequence(
                propertyName,
                parse.between(token.punctuator('('), token.punctuator(')'),
                    propertySetParameterList),
                parse.between(token.punctuator('{'), token.punctuator('}'),
                    functionBody))),
        (loc, name, parameters, body) -> ({
                'loc': loc,
                'key': name,
                'kind': 'set',
                'value': new astExpression.FunctionExpression(loc, null, parameters, body)
            })));

/**
 * Parser for any property initializer.
 */
var propertyInitializer = parse.Parser('Property Initializer',
    parse.choice(
        parse.attempt(propertyValueInitializer),
        propertyGetInitializer,
        propertySetInitializer));

/**
 * Parser for a set or more properties in an object literal.
 */
var objectProperties = parse.Parser('Object Properties',
    parse.bind(
        parse.sepBy(token.punctuator(','),
            propertyInitializer),
        props ->
            parse.always(stream.toArray(props))));

/**
 * Parser for an ECMAScript object literal.
 */
var objectLiteral = parse.Parser('Object Literal',
    ecma_parse.node(
        parse.between(token.punctuator('{'), token.punctuator('}'),
            objectProperties),
        (loc, properties) ->
            new astExpression.ObjectExpression(loc, properties)));

// Function Expression
////////////////////////////////////////
/**
 * Parser for a function's parameters.
 */
var formalParameterList = parse_eager.sepBy(token.punctuator(','),
    value.identifier);

var ecmaFunctionExpression = ecma_parse.nodea(
    parse.next(
        token.keyword('function'),
        parse.sequence(
            parse.optional(value.identifier),
            parse.between(token.punctuator('('), token.punctuator(')'), 
                formalParameterList),
            parse.between(token.punctuator('{'), token.punctuator('}'),
                functionBody))),
    (loc, id, parameters, body) ->
        new astExpression.FunctionExpression(loc, id, parameters, body));

var lambdaFormalParameterList = parse.either(
    parse.between(token.punctuator('('), token.punctuator(')'), 
        formalParameterList),
    parse.bind(value.identifier, x -> parse.always([x])));

var lambdaBody = parse.either(
    parse.between(token.punctuator('{'), token.punctuator('}'),
        functionBody),
    ecma_parse.node(
        expression,
        (loc, x) ->
            new astStatement.BlockStatement(loc, [new astStatement.ReturnStatement(loc, x)])));

var lambdaFunctionExpression = ecma_parse.nodea(
    parse.sequence(
        lambdaFormalParameterList,
        token.punctuator('->'),
        lambdaBody),
    (loc, parameters, _, body) ->
        new astExpression.FunctionExpression(loc, null, parameters, body));

/**
 * Parser for an function expression.
 * 
 * May be named or anon.
 */
var functionExpression = parse.Parser('Function Expression',
    parse.either(
        ecmaFunctionExpression,
        lambdaFunctionExpression));

// This Expression
////////////////////////////////////////
var thisExpression = ecma_parse.node(
    token.keyword('this'),
    loc -> new astExpression.ThisExpression(loc));

// Primary Expression
////////////////////////////////////////
var primaryExpression = parse.Parser('Primary Expression',
    parse.choice(
        thisExpression,
        parse.attempt(parse.bind(
            parse.either(
                value.identifier,
                parse.between(token.punctuator('('), token.punctuator(')'),
                    expression)),
            x -> parse.either(
                parse.next(token.punctuator('->'), parse.never()),
                parse.always(x)))),
        value.literal,
        arrayLiteral,
        objectLiteral,
        functionExpression));

// Calling
////////////////////////////////////////
/**
 * Parser for a list of arguments.
 */
var argumentList = parse.Parser('Argument List',
    parse_eager.sepBy(token.punctuator(','),
        parse.expected("assignment expression", assignmentExpression)));

/**
 * Parser for a argument list part of a call expression.
 */
var args = parse.Parser('Arguments',
    ecma_parse.node(
        parse.between(token.punctuator('('), token.punctuator(')'),
            argumentList),
        (loc, args) -> {
            args.loc = loc;
            args.argument = true;
            return args;
        }));

// Accessors
////////////////////////////////////////
/**
 * Parser for a dot accessor in a member expression.
 */
var dotAccessor = parse.Parser('Dot Accessor',
    ecma_parse.node(
        parse.next(
            token.punctuator('.'),
            value.identifier),
        (loc, x) -> [{
            'loc': loc,
            'property': x,
            'computed': false
        }]));

/**
 * Parser for a bracket accessor in a member expression.
 */
var bracketAccessor = parse.Parser('Bracket Accessor',
    parse.bind(
        parse.between(token.punctuator('['), token.punctuator(']'),
            parse_eager.sepBy1(token.punctuator(','),
                expression)),
        accessor -> parse.always(accessor.map(x -> ({
            'loc': x.loc,
            'property': x,
            'computed': true
        })))));

/**
 * Parser for an accessor in a member expression.
 */
var accessor = parse.Parser('Accessor',
    parse.either(
        dotAccessor,
        bracketAccessor));

var accessorReducer = (p, c) -> 
    new astExpression.MemberExpression(
        position.SourceLocation.merge(p.loc, c.loc),
        p,
        c.property,
        c.computed);

/**
 * 
 */
var memberExpression = (function(){
    var reducer = (p, c) ->
        c.reduce(accessorReducer, p);
        
    return parse.Parser('Member Expression',
        parse.binda(
            parse.sequence(
                parse.either(
                    newExpression,
                    primaryExpression),
                parse.many(accessor)),
            (expression, props) ->
                 parse.always(stream.foldl(reducer, expression, props))));
}());

// New Expression
////////////////////////////////////////
/**
 * Parser for a new expression
 */
var newExpression = parse.Parser('New Expression',
    ecma_parse.nodea(
        parse.next(
            token.keyword('new'),
            parse.sequence(
                parse.expected("member expression", memberExpression),
                parse.optional(args, []))),
        (loc, expression, a) ->
            new astExpression.NewExpression(loc, expression, a)));

// Left Hand Side Expression
////////////////////////////////////////
/**
 * Parser for a left hand side expression.
 */
var leftHandSideExpression = (function(){
    var reducer = (p, c) ->
        (c && c.hasOwnProperty('argument') ?
             new astExpression.CallExpression(position.SourceLocation.merge(p.loc, c.loc), p, c) :
             c.reduce(accessorReducer, p));
    
    return parse.Parser('Left Hand Side Expression',
        parse.binda(
            parse.sequence(
                parse.memo(memberExpression),
                parse.many(parse.either(
                    args,
                    accessor))),
            (member, accessors) ->
                parse.always(stream.foldl(reducer, member, accessors))));
}());

// Unary Expression
////////////////////////////////////////
var unaryOperator = parse.Parser('Unary Operator',
    parse.choice(
        token.keyword('delete'),
        token.keyword('void'),
        token.keyword('typeof'),
        token.punctuator('+'),
        token.punctuator('-'),
        token.punctuator('~'),
        token.punctuator('!')));

/**
 * 
 */
var unaryExpression = (function(){
    var reducer = (argument, op) -> 
        new astExpression.UnaryExpression(
            position.SourceLocation.merge(op.loc, argument.loc),
            op.value,
            argument);
    
    return parse.Parser('Unary Expression',
        parse.binda(
            parse.sequence(
                parse.many(unaryOperator),
                parse.expected('left hand side expression', leftHandSideExpression)),
            (ops, expression) ->
                parse.always(stream.foldr(reducer, expression, ops))));
}());

// Binary Expressions
////////////////////////////////////////
var multiplicativeOperator = parse.choice(
    token.punctuator('*'),
    token.punctuator('/'),
    token.punctuator('%'));

var additiveOperator = parse.either(
    token.punctuator('+'),
    token.punctuator('-'));

var shiftOperator = parse.choice(
    token.punctuator('<<'),
    token.punctuator('>>'),
    token.punctuator('>>>'));

var relationalOperator = parse.choice(
    token.punctuator('<'),
    token.punctuator('>'),
    token.punctuator('<='),
    token.punctuator('>='),
    token.keyword('instanceof'));

var equalityOperator = parse.choice(
    token.punctuator('=='),
    token.punctuator('!='),
    token.punctuator('==='),
    token.punctuator('!=='));

var bitwiseANDOperator = token.punctuator('&');

var bitwiseXOROperator = token.punctuator('^');

var bitwiseOROperator = token.punctuator('|');

var logicalANDOperator = token.punctuator('&&');

var logicalOROperator = token.punctuator('||');

var precedenceTable = [
    {
        'sep': multiplicativeOperator,
        'precedence': 1,
        'node': astExpression.BinaryExpression
    },
    {
        'sep': additiveOperator,
        'precedence': 2,
        'node': astExpression.BinaryExpression
    },
    {
        'sep': shiftOperator,
        'precedence': 3,
        'node': astExpression.BinaryExpression
    },
    {
        'sep': equalityOperator,
        'precedence': 5,
        'node': astExpression.BinaryExpression
    },
    {
        'sep': bitwiseANDOperator,
        'precedence': 6,
        'node': astExpression.BinaryExpression
    },
    {
        'sep': bitwiseXOROperator,
        'precedence': 7,
        'node': astExpression.BinaryExpression
    },
    {
        'sep': bitwiseOROperator,
        'precedence': 8,
        'node': astExpression.BinaryExpression
    },
    {
        'sep': logicalOROperator,
        'precedence': 9,
        'node': astExpression.LogicalExpression
    },
    {
        'sep': logicalANDOperator,
        'precedence': 10,
        'node': astExpression.LogicalExpression
    },
    {
        'sep': relationalOperator,
        'precedence': 4,
        'node': astExpression.BinaryExpression
    }
];

var binaryExpression = parse.Parser('Binary Expression',
    ecma_parse.precedence(unaryExpression, precedenceTable));

// Conditional Expression
////////////////////////////////////////
/**
 * 
 */
var conditionalExpression = (function(){
      var conditionalBody = parse.next(
          token.punctuator('?'),
          parse.sequence(
              parse.expected("assignment expression", assignmentExpression),
              token.punctuator(':'),
              parse.expected("assignment expression", assignmentExpression)));
        
        return parse.bind(binaryExpression, bin -> 
            parse.either(
                ecma_parse.nodea(
                    conditionalBody,
                    (loc, consequent, _1, alternate) ->
                        new astExpression.ConditionalExpression(loc, bin,consequent, alternate)),
                parse.always(bin)));
    
}());

// Let Expression
////////////////////////////////////////
/**
 * 
 */
var letExpression = parse.RecParser('Let Expression', self ->
    parse.either(
        ecma_parse.nodea(
            parse.next(
                token.keyword('let'),
                parse.sequence(
                    value.identifier,
                    token.punctuator('='),
                    conditionalExpression,
                    token.keyword('in'),
                    self)),
                (loc, id, _1, val, _2, expr) ->
                    new astExpression.CallExpression(loc, 
                        new astExpression.FunctionExpression(null, null, [id], new astStatement.BlockStatement(null, [new astStatement.ReturnStatement(null, expr)])),
                        [val])),
        conditionalExpression));

// Assignment Expression
////////////////////////////////////////
var assignmentOperator = parse.Parser('Assignment Operator',
    parse.choice(
        token.punctuator('='),
        token.punctuator('*='),
        token.punctuator('*='),
        token.punctuator('/='),
        token.punctuator('%='),
        token.punctuator('+='),
        token.punctuator('-='),
        token.punctuator('<<='),
        token.punctuator('>>='),
        token.punctuator('>>>='),
        token.punctuator('&='),
        token.punctuator('^='),
        token.punctuator('|=')));

/**
 * 
 */
assignmentExpression = parse.RecParser('Assignment Expression', self ->
    parse.backtrack(parse.either(
        parse.binda(
            parse.attempt(parse.sequence(
                parse.memo(leftHandSideExpression),
                assignmentOperator)),
            function(left, operator) {
                return parse.bind(
                    parse.expected("assignment expression", self),
                    function(right) {
                        return parse.always(new astExpression.AssignmentExpression(
                            position.SourceLocation.merge(left.loc, right.loc),
                            operator.value,
                            left,
                            right));
                });
            }),
        letExpression)));

// Expression
////////////////////////////////////////
expression = assignmentExpression;


/* Export
 ******************************************************************************/
return {
// Array Literal
    'arrayElement': arrayElement,
    'arrayElements': arrayElements,
    'arrayLiteral': arrayLiteral,
    
// Object Literal
    'propertyName': propertyName,
    'propertySetParameterList': propertySetParameterList,
    'propertyValueInitializer': propertyValueInitializer,
    'propertyGetInitializer': propertyGetInitializer,
    'propertySetInitializer': propertySetInitializer,
    'propertyInitializer': propertyInitializer,
    'objectProperties': objectProperties,
    'objectLiteral': objectLiteral,
    
// Primary Expression
    'primaryExpression': primaryExpression,
    
// This Expression
    'thisExpression': thisExpression,
    
// Call Expression
    'args': args,
    'argumentList': argumentList,
    
// Member Expression
    'dotAccessor': dotAccessor,
    'bracketAccessor': bracketAccessor,
    'accessor': accessor,
    'memberExpression': memberExpression,
    
// New Expression
    'newExpression': newExpression,
    
// Left hand side expression
    'leftHandSideExpression': leftHandSideExpression,
    
// Unary Expression
    'unaryOperator': unaryOperator,
    'unaryExpression': unaryExpression,
    
// Binary Expression
    'binaryExpression': binaryExpression,
    
// Conditional Expression
    'conditionalExpression': conditionalExpression,
    
// Assignment Expression
    'assignmentOperator': assignmentOperator,
    'assignmentExpression': assignmentExpression,

// Let Expression
    'letExpression': letExpression,
    
// Expression
    'expression': expression
};

});