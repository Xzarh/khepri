/**
 * @fileOverview
 */
package (
    check)
with
    import 'khepri-ast::node' ast_node#{setUserData},
    import 'khepri-ast::expression' ast_expression,
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::value' ast_value,
    
    import 'neith::zipper' zipper,
    import 'neith::tree' tree,
    
    import 'khepri-ast-zipper' {khepriZipper},
    
    import 'bes::record' record,
    
    import './scope' scope#{Scope}
in {

var reduce = Function.prototype.call.bind(Array.prototype.reduce);

/* Forward declarations
 ******************************************************************************/
var _check;

/* Continuation
 ******************************************************************************/
var Tail = function \f s ok err =self-> {
    self.f = f;
    self.s = s;
    self.ok = ok;
    self.err = err;
};

var trampoline = \f -> {
    var value = f;
    while (value instanceof Tail)
        value = value.f(value.s, value.ok, value.err);
    return value;
};

/* State
 ******************************************************************************/
var State = record.declare(null, [
    'ctx',
    'scope',
    'unique']);

/*
 ******************************************************************************/
var ok = \x -> \s, ok, _ -> ok(x, s);

var error = \x -> \s, _, err -> err(x, s);

var bind = \p f ->
    \s ok err ->
        new Tail(p, s, \x s -> f(x)(s, ok, err), err);

var next = \p n -> bind(p, \_ -> n);

var seqa = \arr -> reduce(arr, next);

var seq = \args(...) -> seqa(args);

var extract = \s ok, _ -> ok(s, s);

var setState = \s -> \_ ok _ -> ok(s, s);

var modifyState = \f -> bind(extract, \s -> setState(f(s)));

var examineState = \f -> bind(extract, \s -> f(s));

var examineScope = \f -> bind(extract, \s -> f(s.scope));

var modifyScope = \f ->
    \s, ok, err -> let
        scope = f(s.scope),
        newState = State.setScope(s, scope)
    in ok(scope, newState);

var setScope = \s -> modifyScope(\() -> s);

var unique = \s, ok, err -> ok(s.unique, s.setUnique(s.unique + 1));

/* Movement
 ******************************************************************************/
var move = \op ->
    modifyState(\s ->
        State.setCtx(s, op(s.ctx)));

var up = move zipper.up;
var down = move zipper.down;
var left = move zipper.left;
var right = move zipper.right;

var child = \f edge ->
    seq(
        move tree.child@edge,
        f,
        up);

var checkCtx = \node ->
    _check <| (node && tree.node(node));

var checkTop = \s ok err ->
    checkCtx(s.ctx)(s, ok, err);

var checkChild = child@checkTop;

var inspect = \f ->
    examineState(\s -> f(tree.node s.ctx));

var modifyNode = \f -> move tree.modifyNode@f;

var setNode = \x -> move tree.setNode@x;

/* Operations
 ******************************************************************************/
var pass = ok();

/**
 * Create a new lexical block for body.
 */
var block = \body(...) ->
    examineScope <|\ s ->
        seq(
            setScope(scope.push(s)),
            seqa(body),
            setScope(s));

/**
 * Check to ensure the current scope contains a binding for `id`.
 */
var checkHasBinding = \id, loc ->
    examineScope <|\ s ->
        ?s.hasBinding(id)
            :pass
            :error("Undeclared identifier:'" + id + "' at:" + loc);

/**
 * Check to ensure the current scope does not have has a binding for `id`.
 */
var checkCanAddOwnBinding = \id loc -> 
    examineScope <|\ s ->
        ?!s.hasOwnBinding(id)
            :pass
            :let
                start = loc && loc.start,
                binding = s.getBinding(id),
                end = binding.loc && binding.loc.start
            in
                error("'" + id + "' at:" + start + " already bound for scope from:" + end);

/**
 * Check if `id` is a mutable binding.
 */
var checkCanAssign = \id, loc -> 
    examineScope <|\ s ->
        ?s.hasBinding(id)
            :let b = s.getBinding(id) in
                ?b.mutable
                    :pass
                    :error("Assign to immutable variable:'" + id + "' at:"+ loc)
            :pass;

/**
 * Define a new identifier and create a uid entry for it.
 */
var addUid  = \id ->
    bind(unique, \uid ->
        modifyScope(\s -> Scope.addUid(s, id, uid)));

/**
 * Add a new mutable binding in the current scope.
 * Does not perform any checks.
 */
var addMutableBinding = \id, loc -> 
    seq(
         modifyScope(\s -> Scope.addMutableBinding(s, id, loc)),
         addUid(id));

/**
 * Adds a new immutable binding in the current scope.
 * Does not perform any checks.
 */
var addImmutableBinding = \id, loc -> 
    seq(
         modifyScope(\s -> Scope.addImmutableBinding(s, id, loc)),
         addUid(id));

/**
 * Add a new mutable binding in the current scope.
 * Checks to make sure the new binding is valid.
 */
var addMutableBindingChecked = \id, loc ->
    seq(
        checkCanAddOwnBinding(id, loc),
        addMutableBinding(id, loc));

/**
 * Add a new immutable binding in the current scope.
 * Checks to make sure the new binding is valid.
 */
var addImmutableBindingChecked = \id, loc ->
    seq(
        checkCanAddOwnBinding(id, loc),
        addImmutableBinding(id, loc));

/* Checks
 ******************************************************************************/
var checks = {};

var addCheck = \type, check -> {
    if (Array.isArray(type))
        type.forEach <|\x -> addCheck(x, check);
    else
        checks.(type) = check;
};

// Program and Packages
addCheck@'Program' <|
    checkChild 'body';

addCheck@'PackageExports' <|
    checkChild 'exports';

addCheck@'PackageExport' <|
    inspect <|\ node ->
        addMutableBindingChecked(node.id.name, node.loc);

addCheck@'Package' <|
    seq(
        addImmutableBindingChecked('require', null),
        addImmutableBindingChecked('exports', null),
        addImmutableBindingChecked('module', null),
        checkChild 'exports',
        inspect <|\ node ->
            ?node.body.type === 'WithStatement'
                :child(
                    seq(
                        checkChild 'bindings',
                        child(checkChild 'body', 'body')),
                    'body')
                :child(checkChild 'body', 'body'));

// Clause
addCheck@'SwitchCase' <|
    seq(
        checkChild 'test',
        checkChild 'consequent');

addCheck@'CatchClause' <|
    block(
        inspect <|\ node ->
            addImmutableBindingChecked(node.param.name, node.param.loc),
        checkChild 'param',
        child(
            checkChild 'body',
            'body'));

// Declarations
addCheck@['StaticDeclaration', 'VariableDeclaration'] <|
    checkChild 'declarations';

addCheck@'StaticDeclarator' <|
    inspect <|\ node ->
        addImmutableBindingChecked(node.id.name, node.loc);
    
addCheck@'VariableDeclarator' <|
    seq(
        inspect <|\ node ->
            addMutableBindingChecked(node.id.name, node.loc),
        checkChild 'id',
        checkChild 'init');
    
addCheck@'Binding' <|
    seq(
        checkChild 'pattern',
        checkChild 'value');

// Statement
addCheck@'BlockStatement' <|
    block(
        checkChild 'body');

addCheck@'ExpressionStatement' <|
    checkChild 'expression';

addCheck@'IfStatement' <|
    seq(
        checkChild 'test',
        block(
            checkChild 'consequent'),
        block(
            checkChild 'alternate'));

addCheck@'WithStatement' <|
     block(
        checkChild 'bindings',
        child(checkChild 'body', 'body'));

addCheck@'SwitchStatement' <|
    block(
        checkChild 'discriminant',
        checkChild 'cases');

addCheck@['ReturnStatement', 'ThrowStatement'] <|
    checkChild 'argument';

addCheck@'TryStatement' <|
    seq(
        checkChild 'block',
        block(
            checkChild 'handler'),
        block(
            checkChild 'finalizer'));

addCheck@'WhileStatement' <|
    seq(
        checkChild 'test',
        block(
            checkChild 'body'));

addCheck@'DoWhileStatement' <|
    seq(
        block(
            checkChild 'body'),
        checkChild 'test');

addCheck@'ForStatement' <|
    block(
        checkChild 'init',
        checkChild 'test',
        checkChild 'update',
        block(
            checkChild 'body'));

// Expression
addCheck@'FunctionExpression' <|
    block(
         inspect <|\ node ->
             ?node.id
                 :addImmutableBinding(node.id.name, node.loc)
                 :pass,
         checkChild 'params',
         inspect <|\ node ->
             ?node.body.type === "BlockStatement"
                 :child(checkChild 'body', 'body')
                 :checkChild 'body');

addCheck@'UnaryExpression' <|
    checkChild 'argument';

addCheck@'AssignmentExpression' <|
    seq(
        checkChild 'left',
        inspect <|\ node ->
            ?node.left.type === 'Identifier'
                :checkCanAssign(node.left.name, node.left.loc)
                :pass,
        checkChild 'right');

addCheck@['LogicalExpression','BinaryExpression'] <|
    seq(
        checkChild 'left',
        checkChild 'right');

addCheck@'ConditionalExpression' <|
    seq(
        checkChild 'test',
        checkChild 'consequent',
        checkChild 'alternate');

addCheck@['CallExpression', 'NewExpression'] <|
    seq(
        checkChild 'callee',
        checkChild 'args');

addCheck@'MemberExpression' <|
    seq(
        checkChild 'object',
        inspect <|\ node ->
            ?node.computed
                :checkChild 'property'
                :pass);
    
addCheck@'ArrayExpression' <|
    checkChild 'elements';

addCheck@'ObjectExpression' <|
    checkChild 'properties';

addCheck@'LetExpression' <|
    block(
        checkChild 'bindings',
        checkChild 'body');

addCheck@'CurryExpression' <|
    seq(
        checkChild 'base',
        checkChild 'args');

// Patterns
addCheck@'SinkPattern'<|
    bind(unique, \uid ->
        setNode <|
            setUserData(
                ast_value.Identifier.create(null, '_'),
                {'uid': uid}));

addCheck@'IdentifierPattern' <|
    inspect <|\ node ->
        seq(
            ?node.reserved
                :addImmutableBinding(node.id.name, node.loc)
                :addImmutableBindingChecked(node.id.name, node.loc),
            checkChild 'id');

addCheck@'ImportPattern' <|
    checkChild 'pattern';

addCheck@'AsPattern' <|
    seq(
        checkChild 'id',
        inspect <|\ node -> child(
            seq(
               modifyNode(\target -> {
                    var n = setUserData(target, target.ud || {});
                    n.ud.id = node.id;
                    return n;
                }),
                checkTop),
            'target'));

addCheck@['ObjectPattern', 'ArrayPattern'] <|
    inspect <|\ node -> {
        if (!node.ud || !node.ud.id) {
            return seq(
                bind(unique, \uid -> {
                    var id = ast_pattern.IdentifierPattern.create(node.loc,
                        setUserData(
                            ast_value.Identifier.create(null, '__o'),
                            {'uid': uid}));
                    
                    //TODO: Hack. Tells later check not to complain if '__o' is not unique
                    // because this doesn't matter since the uid is unique.
                    id.reserved = true;
                    
                    return setNode(ast_pattern.AsPattern.create(null, id, node));
                }),
                checkTop);
        }
        return checkChild 'elements';
    };

addCheck@'ObjectPatternElement' <|
    seq(
        checkChild 'target',
        checkChild 'key');

addCheck@'ArgumentsPattern' <|
    seq(
        checkChild 'id',
        checkChild 'elements',
        checkChild 'self');

// Value
addCheck@'ObjectValue' <|
    checkChild 'value';

addCheck@'Identifier' <|
    inspect <|\ node ->
        seq(
            examineScope <|\ s ->
                 setNode <| setUserData(node, {'uid': s.getUid(node.name)}),
            checkHasBinding(node.name, node.loc));

/*
 ******************************************************************************/
_check = \node -> {
    if (Array.isArray(node)) {
        if (!node.length)
            return pass;
        
        return seq(
            down,
            seqa(node.map(\_ i -> 
                ?i === node.length - 1
                    :checkTop
                    :next(checkTop, right))),
            up);
    }
    
    if (node instanceof ast_node.Node && checks.(node.type))
        return checks.(node.type);
    
    return pass;
};


/**
 * 
 */
var checkAst = \ast globals -> {
    var scope = reduce(globals || [], Scope.addImmutableBinding, new Scope({}, null, {}, {}));
    var state = new State(khepriZipper(ast), scope, 1);
    return trampoline(checkTop(state, \x s -> (s.ctx |> zipper.root |> tree.node), \err, s -> { throw err; }));
};

/**
 * 
 */
check = \ast globals ->
    checkAst(ast, globals);


}