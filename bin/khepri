#!/usr/bin/env node

var path = require('path');
var fs = require('fs');

var mkdirp = require('mkdirp');

var unparse = require('ecma-unparse').unparse;
var unparse_print = require('ecma-unparse').print;

var lexer = require('khepri-parse').lex.lexer;
var parser = require('khepri-parse').parse.parser;
var khepri_compile = require('khepri-compile').compile;
console.log(khepri_compile);
var KHEPRI_EXT = /^\.kep$/i;


var compile = function(input, header, options, ok, err) {
    try {
        var lex = lexer.lex(input);
        var ast = parser.parseStream(lex);
        var unparsed = unparse.unparse(khepri_compile.compile(ast, options));
        return ok(header + unparse_print.print(unparsed));
    } catch (e) {
        return err(e.stack + '');
    }
};

var compileFile = function(inFile, outFile, header, options, ok, error) {
    fs.realpath(inFile, function(err, resolvedPath) {
        if (err) throw err;
        
        // Walk sub directories and compile all `*.kep` files.
        if (fs.lstatSync(resolvedPath).isDirectory())
            return fs.readdir(resolvedPath, function(err, files) {
                files.forEach(function(file) {
                    var subPath = path.join(inFile, file);
                    
                    if (fs.lstatSync(subPath).isDirectory()){
                        return compileFile(
                            subPath,
                            outFile && path.join(outFile, file),
                            header,
                            options,
                            ok,
                            error);
                    }
                    
                    if (path.extname(file).match(KHEPRI_EXT))
                        return compileFile(
                            subPath,
                            outFile && path.join(outFile, path.basename(file, '.kep') + '.js'),
                            header,
                            options,
                            ok, error);
                });
            });
        
        fs.readFile(resolvedPath, 'utf8', function(err, data) {
            if (err) throw err;
            
            if (outFile)
                console.log("Khepri'" + inFile + "' to:'" + outFile + "'");

            compile(data, header, options,
                function(data) { ok(data, inFile, outFile); },
                function(data) { error(data, inFile, outFile); });
        });
    });
};


// Arguments
var argParse = require('optimist')
    .wrap(80)
    .usage(
        ["Compile Khepri to Javascript.",
        "",
        "Usage: khepri [options] [-o out_file] [in_file]",
        "",
        "Compiles Khepri input from `in_file` to Javascript in `out_file`. If `in_file` is",
        "not specified, reads input from stdin. If `in_file` is a directory, compiles all",
        "*.kep files to output files paths building to paths rooted at `out_file`",
        "When `out_file` is not specified, writes output to stdout."].join('\n'))
    .boolean('help')
        .describe('help', "Print usage info")
    .boolean('version')
        .describe('version', "Print version number")
    .boolean('watch')
        .describe('watch', "Watch for for changes")
    .alias('w', 'watch')
    .options('o', {
        'describe': 'Output file or directory'
    })
    .options('package_manager', {
        'default': 'amd',
        'describe': 'Package manager to target. (amd | node)'
    })
    .options('header', {
        'describe': 'Javascript header to prefix output.'
    });

var argv = argParse.argv;

if (argv.version) {
    var pack = require(path.join(root, 'package.json'));
    process.stdout.write(pack.version + '\n');
    return 0;
}

if (argv.help) {
    argParse.showHelp(process.stdout.write.bind(process.stdout));
    return 0;
}


var inFile = argv._[0],
    outFile = argv['o'];

var options = {};
if ('package_manager' in argv) options.package_manager = argv.package_manager;

var err = function(e) { console.error(e + ''); };
var ok = (!outFile ?
    function(x) {
        process.stdout.setEncoding('utf8');
        process.stdout.write(x);
    } :
    function(out, inFile, outFile) {
        mkdirp(path.dirname(outFile), function(err) {
            fs.writeFile(outFile, out, 'utf8', function(err) {
                if (err) throw err;
                console.log("Compiled '" + inFile + "' to '" + outFile + "'");
            });
        });
    });


if (argv.watch) {
    var watchr = require('watchr');
    if (!inFile) {
        process.stdout.write('No input directory specified, watching current directory\n');
        inFile = process.cwd();
    }
    
    if (!outFile) {
        process.stdout.write('No output directory specified, outputting to input directory\n');
        outFile = inFile;
    }
    
    watchr.watch({
        paths: [inFile],
        listeners: {
            'change': function(changeType, filePath, fileCurrentStat, filePreviousStat) {
                if (path.extname(filePath).toLowerCase() !== '.kep') return;
                
                var rel = path.relative(inFile, filePath);
                var base = path.basename(rel, '.kep');
                var dir = path.dirname(rel);
                
                var out = path.join(outFile, dir, base + '.js');
                
                // Delete generated code when source is deleted
                /*if (changeType === 'delete') {
                    if (fs.lstatSync(out).isFile())
                        fs.unlink(out);
                    return;
                }*/
                
                var header = 'header' in argv ?
                    argv['header'] :
                    "/*\n * THIS FILE IS AUTO GENERATED from " +
                        path.join(inFile, rel) +
                        "\n * DO NOT EDIT\n*/\n";
                
                compileFile(filePath, out, header, options, ok, err);
            }
        }
    });
    return 0;
}

var header = (argv['header'] ? argv['header'] + '\n' : '');

if (!inFile) {
    process.stdin.resume();
    process.stdin.setEncoding('utf8');
    process.stdin.on('data', function(data) {
        compile(data, header, options, ok, err);
    });
} else {
    compileFile(inFile, outFile, header, options, ok, err);
}
